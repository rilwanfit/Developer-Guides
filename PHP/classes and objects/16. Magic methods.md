## Magic Methods

In addition to __construct() and __destruct(), several other magic methods were added to allow you to hook into certain operations performed on the class, or instances of the class in which they are defined.

Magic methods allow you to do complex things, such as transforming data between structures using property overloading, or creating dynamic APIs using method overloading.

However, they are called magic methods for a reason. The use of these methods injects a certain amount of uncertainty into the way your object interacts, and in particular can stop IDEs from being able to perform autocompletion.

### Overloading

Overloading in PHP provides means to dynamically "create" properties and methods. These dynamic entities are processed via magic methods one can establish in a class for various action types.

The overloading methods are invoked when interacting with properties or methods that have not been declared or are not visible in the current scope. The rest of this section will use the terms "inaccessible properties" and "inaccessible methods" to refer to this combination of declaration and visibility.

All overloading methods must be defined as public.

Note: None of the arguments of these magic methods can be passed by reference.

Note: PHP's interpretation of "overloading" is different than most object oriented languages. Overloading traditionally provides the ability to have multiple methods with the same name but different quantities and types of arguments.


#### Property overloading

WHEN ACCESSING NON-EXISTENT PROPERTIES, PHP WILL EXECUTE SPECIAL ("MAGIC") FUNCTIONS, IF AVAILABLE

__set() is run when **writing** data to inaccessible **properties**.

__get() is utilized for **reading** data from inaccessible **properties**.

__isset() is triggered by calling isset() or empty() on inaccessible properties. CHECKS IF THE PROPERTY IS SET

__unset() is invoked when unset() is used on inaccessible properties. UNSETS OR DESTROYS A PROPERTY

Property overloading only works in object context. These magic methods will not be triggered in static context. Therefore these methods should not be declared static. As of PHP 5.3.0, a warning is issued if one of the magic overloading methods is declared static.

Note:

The return value of __set() is ignored because of the way PHP processes the assignment operator. Similarly, __get() is never called when chaining assignments together like this:

$a = $obj->b = 8;

Example #1 Overloading properties via the __get(), __set(), __isset() and __unset() methods

```php
class PropertyTest {
  /** Location for overloaded data.  */
  private $data = [];
  /** Overloading not used on declared properties.  */
  public $declared = 1;
  /** Overloading only used on this when accessed outside the class.  */
  private $hidden = 2;

  public function set($name, $value) {
   echo "Setting '$name' to '$value'\n";
   $this->data[$name] = $value;
  }

  public function get($name) {
    echo "Getting '$name'\n";
    if (array_key_exists($name, $this->data)) {
      return $this->data[$name];
    }

    $trace = debug_backtrace();

    trigger_error(
      'Undefined property via get(): ' . $name .
      ' in ' . $trace[0]['file'] .
      ' on line ' . $trace[0]['line'],
      E_USER_NOTICE
    );

    return null;
  }

  /* As of PHP 5.1.0 /
  public function isset($name) {
    echo "Is '$name' set?\n";
    return isset($this->data[$name]);
  }

  /** As of PHP 5.1.0 */
  public function __unset($name) {
    echo "Unsetting '$name'\n";
    unset($this->data[$name]);
  }

  /** Not a magic method, just here for example. */
  public function getHidden() {
    return $this->hidden;
  }
}
```


<table>
  <tr>
   <td>$obj = new PropertyTest;
<p>
$obj->a = 1;                // Setting 'a' to '1'
<p>
echo $obj->a;               // Getting 'a'  1
<p>
var_dump(isset($obj->a));      // Is 'a' set?  bool(true)
<p>
unset($obj->a);                 // Unsetting 'a'
<p>
var_dump(isset($obj->a));      // Is 'a' set?  bool(false)
<p>
echo $obj->declared;      // 1
<p>
echo "Let's experiment with the private property named 'hidden':";
<p>
echo "Privates are visible inside the class, so __get() not used...";
<p>
echo $obj->getHidden();      // 2
<p>
echo "Privates not visible outside of class, so __get() is used...\n";
<p>
echo $obj->hidden;         // Getting 'hidden'
<p>
// Notice:  Undefined property via __get(): hidden in <file> on line……
   </td>
  </tr>
</table>


Note: Overloading not used for public properties


#### Method overloading

[__call()](http://php.net/manual/en/language.oop5.overloading.php#object.call) is triggered when invoking inaccessible methods in an object context.

[__callStatic()](http://php.net/manual/en/language.oop5.overloading.php#object.callstatic) is triggered when invoking inaccessible methods in a static context.

```php
class MethodTest
{
    public function __call($name, $arguments)
    {
        // Note: value of $name is case sensitive.
        echo "Calling object method '$name' "
            . implode(', ', $arguments). "\n";
    }
    
    /** As of PHP 5.3.0 */
    public static function __callStatic($name, $arguments)
    {
        // Note: value of $name is case sensitive.
        echo "Calling static method '$name' "
            . implode(', ', $arguments). "\n";
    }
}
```

```php
class Foo {
    function __call($m, $a) {
        die($m);
    }
}

$foo = new Foo;

print $foo->{'wow!'}();
```

```php
$obj = new MethodTest;
$obj->runTest('in object context'); // Calling object method 'runTest' in object context

MethodTest::runTest('in static context'); // Calling static method 'runTest' in static context
```

Warning!  __get, __set, and __call as a way to access the data in your class will prevent any sort of autocomplete, highlighting, or documentation that your IDE might do.

If you still decide to use __get and __set for everything in your class, be sure to include detailed comments and documenting, so that the people you are working with (or the people who inherit the code from you at a later date) don't have to waste time interpreting your code just to be able to use it.

[https://github.com/myclabs/DeepCopy](https://github.com/myclabs/DeepCopy)
