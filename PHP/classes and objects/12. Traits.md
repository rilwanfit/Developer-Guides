## TRAITS


### Leverage vs Abstraction

Chunks of code (functions, classes, methods, etc) can be split out for either abstraction or leverage.

*   **Abstraction** gathers similar code behind a higher level concept that's more concise for other code to work with.
    *   Interfaces helps us build and enforce abstractions
*   **Leverage** gathers similar code together so you only have one place to change it.
    *   Inheritance, traits

A common abstraction would be a Repository: you don't know how an object is being stored or where but you don't care. The details are behind the concept of a Repository.

Common leverage would be something like your framework's Controller base class. It doesn't hide much, it just adds some nifty shortcuts that are easier to work with.

[http://rosstuck.com/how-i-use-traits/](http://rosstuck.com/how-i-use-traits/)

[http://culttt.com/2014/06/25/php-traits](http://culttt.com/2014/06/25/php-traits)

[https://gist.github.com/adamwathan/120f5acb69ba84e3fa911437242796c3](https://gist.github.com/adamwathan/120f5acb69ba84e3fa911437242796c3)

• A CONSTRUCT THAT ENCAPSULATES REUSABLE PROPERTIES AND METHODS

• A TRAIT IS LIKE A NON-INSTANTIABLE CLASS

• CLASSES CAN USE TRAITS

• KEYWORD trait TO DEFINE A TRAIT, KEYWORD use TO USE IT WITHIN A CLASS

• TRAIT PRECENDENCE: CURRENT CLASS MEMBERS > TRAIT METHODS > INHERITED METHODS

• MAY CHANGE VISIBILITY OF TRAIT METHODS USING THE as KEYWORD: class c { use t { method1 as protected; } }

• A CLASS MAY USE MULTIPLE TRAITS

O FATAL ERROR IF TRAITS HAVE CONFLICTING NAMES

• CONFLICT RESOLUTION WITH insteadof OPERATOR: use t1, t2 { t1::method1 insteadof t2; }

• CAN ALSO USE ALIASING:

use t1, t2 { t2::method1 as method1_from_t2; }
