## Static Methods and Properties
PHP 5 also implements **static** methods and properties. Unlike regular methods and properties, their static counterparts exist and

are accessible as part of a class itself, as opposed to existing only within the scope of one of its instances. This allows you to treat classes as true containers of interrelated functions and data elements, which, in turn, is a very handy expedient to avoid naming conflicts.

While PHP 4 allowed you to call any method of a class statically using the scope resolution operator **::** (officially known as _Paamayim Nekudotayim_— Hebrew for "Double Colon"), PHP 5 introduces a stricter syntax that calls for the use of the **static** keyword to convey the use of properties and methods as such.

PHP is very strict about the use of static properties;

*   calling static properties using object notation (i.e. $obj->property) will result in both a "strict standards" message and a notice.
*   This is not the case with static methods, however calling a non-static method statically will also emit a "strict standards" message.

 ```php
class Foo {
   static $bar = "bat";
   public static function baz() {
       echo "Hello World";
   }
}
$foo = new Foo();
$foo->baz();
echo $foo->bar;
```

This example will display:

```bash
Hello WorldPHP Strict Standards:  Accessing **static** property
     foo::$bar **as** non **static** in PHPDocument1 on line 17
Strict Standards: Accessing **static** property foo::$bar **as**
     non **static** in PHPDocument1 on line 1
```

The correct way to call static methods and properties is like so:
```
    Foo::baz();
    echo Foo::$bar;
```
In addition to declaring a method static, you can set the visibility with the regular methods, using public, protected, and private.

The order of the static keyword and a visibility keyword does not matter. If no visibility definition is declared, the static method or property is considered public.

*   SCOPE RESOLUTION OPERATOR

Token that permits access to the static, CONSTANT, OR overridden properties / methods of a class.

*   Use the class name whenever referencing these element outside of the class definition
*   Self always refers to the current class; parent refers to the parent of the current class (the one it inherits)
*   Static context is working with a class directly and NOT with object


#### When to use static methods

[http://verraes.net/2014/06/when-to-use-static-methods-in-php/](http://verraes.net/2014/06/when-to-use-static-methods-in-php/)


### Dynamic calling
*   It is possible to use variable variables to access static methods:

```
$var = 'bar';
echo foo::$$var;
```

*   PHP 5.3 added the ability to use a variable class name for static access:

    ```
$className = 'foo';
$className::baz();
echo $className::$bar;
```

*   PHP 5.4 added support for dynamic static method access using the ClassName::$var or ClassName::{expression}() syntax

    ```
$method = 'baz';
foo::$method();
// or
foo::{$method}();
```
As with dynamic object method calls, you can use any expression inside the curly braces.

### Self and Late Static Binding

[http://php.net/manual/en/language.oop5.late-static-bindings.php](http://php.net/manual/en/language.oop5.late-static-bindings.php)

**self::** which is often used similarly to **$this** in static contexts, although it doesn't quite work the same way.

**$this**  Which refers to the current instance and has the scope of the class that was instantiated.

**Self::** Like the magic constant __CLASS__— refers to the class in which the call is defined.

This means that if you have a parent class with a method that references **self::** to call a method that is overridden in a child class, when you call the method inherited

from the parent, it will call the parent's version of the method, not the child's, and in the parent's context, meaning that visibility has no impact.

```
class a {
  public static function test() {
    self::<em>foo</em>();
    self::<em>bar</em>();
  }

  public static function foo() {
    echo <em>__METHOD__ </em>. " called\n";
  }

  private static function bar() {
    echo <em>__METHOD__ </em>. " called\n";
  }
}
```

```
class b extends a { }
class c extends a {
  public static function foo() {
    echo <em>__METHOD__ </em>. " called\n";
  }
  private static function bar() {
    echo <em>__METHOD__ </em>. " called\n";
  }
}

a::<em>test</em>();  // a::foo called // a::bar called
b::<em>test</em>();  // a::foo called // a::bar called
c::<em>test</em>();  // a::foo called // a::bar called
```
Notice how b::test(), which inherits the a class's static methods, is still calling a::foo() and a::bar(), and c::test(), which overrides the methods in a, still calls them from the context of a.

PHP 5.3.0 introduced late static binding (also known as LSB), which will determine the current class at runtime. It has similar semantics to **$this** and refers to wherever the call happens, not the definition, but with the context of wherever it is defined. This is achieved by using the **static::** identifier

```
class a {
   public static function test() {
       static::foo();
       static::bar();
   }
   public static function foo() {
       echo __METHOD__ . " called\n";
   }
   private static function bar() {
       echo __METHOD__ . " called\n";
   }
}
class b extends a { }
class c extends a
{
   public static function foo() {
       echo __METHOD__ . " called\n";
   }
   private static function bar() {
       echo __METHOD__ . " called\n";
   }
}
a::test();  // a::foo called // a::bar called
b::test();  // a::foo called // a::bar called
c::test();  // c::foo called // Fatal error: Call to private method c::bar() from context 'a'
```

This time, b::test() doesn't change its behavior from before, as it simply inherits the methods from a. However, c::test() now shows that it is calling the overriding methods, but still from the context of a, so while we can call the public c::foo(), we get a fatal error calling the private c::bar().

Conclusion:

*   **self::** points to **the class in which it is written.**
*   **new self();** equals to **new MyClass();**
*   **static::** sort of points to **the class that is used NOT **the class in which it is written.


### static vs. self

Using static over self can result in undesirable issues when a Value Object inherits from another Value Object.

By using the self keyword we do not couple the code with the class name. As such, a change to the class name or namespace will not effect the factory methods who uses self. This small implementation detail aids when refactoring the code at a later date.


### Constructors / Destructors

The **new** keyword creates a new instance of the class. In addition, it runs a method called a constructor that we can use to initialize and configure the object. In PHP 5, constructors are named __construct().

*   __destruct() is a reserved method name for the class destructor
    *   If a class maintain an open file handler OR connection throughout its life, then the __destruct() method is a good place for a close-type operation.
*   __destruct() is called whenever an object is destroyed (When all its references are removed OR the end of the script) is reached.

Class name construct vs __construct;


```
class A {
   function __construct() {
       echo 'New way construct';
   }
   function A() {
       echo 'old way construct';
   }
}
$aa = new A();
```


"New way construct" will be echoed. If you defined the __construct method after declaring A(). you will get results as follows

New way constract

**E_STRICT : **type 2048 -- Redefining already defined constructor for class A

NOTE: we can call the construct method anytime as we want. Ex:

```
$aa = new A(); // old way construct

$aa->A();         //old way construct

$aa->A();        // old way construct
```

#### Don't call the destructor Explicitly

Well, as we can not call the constructor explicitly: we should not call the destructor explicitly.

This won't destroy the object and it is still valid PHP code.

```
$aa->__construct();
$aa->__destruct();
```

[http://www.stoimen.com/blog/2011/11/14/php-dont-call-the-destructor-explicitly/](http://www.stoimen.com/blog/2011/11/14/php-dont-call-the-destructor-explicitly/)

#### Named Constructor

[http://verraes.net/2014/06/named-constructors-in-php/](http://verraes.net/2014/06/named-constructors-in-php/)

