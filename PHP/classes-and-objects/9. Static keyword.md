---
id: static-keyword
title: DDD
---

## Static Methods and Properties
PHP 5 also implements **static** methods and properties. Unlike regular methods and properties, their static counterparts exist and

are accessible as part of a class itself, as opposed to existing only within the scope of one of its instances. This allows you to treat classes as true containers of interrelated functions and data elements, which, in turn, is a very handy expedient to avoid naming conflicts.

While PHP 4 allowed you to call any method of a class statically using the scope resolution operator **::** (officially known as _Paamayim Nekudotayim_— Hebrew for "Double Colon"), PHP 5 introduces a stricter syntax that calls for the use of the **static** keyword to convey the use of properties and methods as such.

PHP is very strict about the use of static properties;

*   calling static properties using object notation (i.e. $obj->property) will result in both a "strict standards" message and a notice.
*   This is not the case with static methods, however calling a non-static method statically will also emit a "strict standards" message.

 ```php
class Foo {
   static $bar = "bat";
   public static function baz() {
       echo "Hello World";
   }
}
$foo = new Foo();
$foo->baz();
echo $foo->bar;
```

This example will display:

```bash
Hello WorldPHP Strict Standards:  Accessing **static** property
     foo::$bar **as** non **static** in PHPDocument1 on line 17
Strict Standards: Accessing **static** property foo::$bar **as**
     non **static** in PHPDocument1 on line 1
```

The correct way to call static methods and properties is like so:
```php
    Foo::baz();
    echo Foo::$bar;
```
In addition to declaring a method static, you can set the visibility with the regular methods, using public, protected, and private.

The order of the static keyword and a visibility keyword does not matter. If no visibility definition is declared, the static method or property is considered public.

*   SCOPE RESOLUTION OPERATOR

Token that permits access to the static, CONSTANT, OR overridden properties / methods of a class.

*   Use the class name whenever referencing these element outside of the class definition
*   Self always refers to the current class; parent refers to the parent of the current class (the one it inherits)
*   Static context is working with a class directly and NOT with object


#### When to use static methods

[http://verraes.net/2014/06/when-to-use-static-methods-in-php/](http://verraes.net/2014/06/when-to-use-static-methods-in-php/)


### Dynamic calling
*   It is possible to use variable variables to access static methods:

```php
$var = 'bar';
echo foo::$$var;
```

*   PHP 5.3 added the ability to use a variable class name for static access:

```php
$className = 'foo';
$className::baz();
echo $className::$bar;
```

*   PHP 5.4 added support for dynamic static method access using the ClassName::$var or ClassName::{expression}() syntax

```php
$method = 'baz';
foo::$method();
// or
foo::{$method}();
```
As with dynamic object method calls, you can use any expression inside the curly braces.

### Self and Late Static Binding

[http://php.net/manual/en/language.oop5.late-static-bindings.php](http://php.net/manual/en/language.oop5.late-static-bindings.php)

**self::** which is often used similarly to **$this** in static contexts, although it doesn't quite work the same way.

**$this**  Which refers to the current instance and has the scope of the class that was instantiated.

**Self::** Like the magic constant __CLASS__— refers to the class in which the call is defined.

This means that if you have a parent class with a method that references **self::** to call a method that is overridden in a child class, when you call the method inherited

from the parent, it will call the parent's version of the method, not the child's, and in the parent's context, meaning that visibility has no impact.

```php
class a {
  public static function test() {
    self::<em>foo</em>();
    self::<em>bar</em>();
  }

  public static function foo() {
    echo <em>__METHOD__ </em>. " called\n";
  }

  private static function bar() {
    echo <em>__METHOD__ </em>. " called\n";
  }
}
```

```php
class b extends a { }
class c extends a {
  public static function foo() {
    echo <em>__METHOD__ </em>. " called\n";
  }
  private static function bar() {
    echo <em>__METHOD__ </em>. " called\n";
  }
}

a::<em>test</em>();  // a::foo called // a::bar called
b::<em>test</em>();  // a::foo called // a::bar called
c::<em>test</em>();  // a::foo called // a::bar called
```
Notice how b::test(), which inherits the a class's static methods, is still calling a::foo() and a::bar(), and c::test(), which overrides the methods in a, still calls them from the context of a.

PHP 5.3.0 introduced late static binding (also known as LSB), which will determine the current class at runtime. It has similar semantics to **$this** and refers to wherever the call happens, not the definition, but with the context of wherever it is defined. This is achieved by using the **static::** identifier

```php
class a {
   public static function test() {
       static::foo();
       static::bar();
   }
   public static function foo() {
       echo __METHOD__ . " called\n";
   }
   private static function bar() {
       echo __METHOD__ . " called\n";
   }
}
class b extends a { }
class c extends a
{
   public static function foo() {
       echo __METHOD__ . " called\n";
   }
   private static function bar() {
       echo __METHOD__ . " called\n";
   }
}
a::test();  // a::foo called // a::bar called
b::test();  // a::foo called // a::bar called
c::test();  // c::foo called // Fatal error: Call to private method c::bar() from context 'a'
```

This time, b::test() doesn't change its behavior from before, as it simply inherits the methods from a. However, c::test() now shows that it is calling the overriding methods, but still from the context of a, so while we can call the public c::foo(), we get a fatal error calling the private c::bar().

Conclusion:

*   **self::** points to **the class in which it is written.**
*   **new self();** equals to **new MyClass();**
*   **static::** sort of points to **the class that is used NOT **the class in which it is written.


### static vs. self

Using `static` over `self` can result in undesirable issues when a Value Object inherits from another Value Object.

By using the `self` keyword we do not couple the code with the class name. As such, a change to the class name or namespace will not effect the factory methods who uses self. This small implementation detail aids when refactoring the code at a later date.

### 5 usage of static keywords
https://www.exakat.io/5-usages-of-static-keyword-in-php/

#### static method
```php
public static function aStaticMethod() {
  $var = 'this';
  var_dump($$var);  // NULL
}

public static function anotherStaticMethod() {
  var_dump($this);  // Warning: Uncaught Error: Using $this when not in object context
}
```

- `$this` is not available in such methods.
- Since static methods do not depends on an object, they are great for factories. They are also useful to access the private static properties, since both of them are static. Finally, they are also useful for utils that are related to a class but not depend on local object state : however, those may be considered as a function.

#### static property
They do not depend on the object, but only on the class itself
#### static closure
#### static variable
#### static as a classname