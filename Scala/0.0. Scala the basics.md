#Basics

## Variables
scala has two kinds of variables```vals``` and ```vars```
- ```val``` once initialized, can never be reassigned
- ```var``` can be reassigned throughout its lifetime

``` 
val mgs: String = "Hello"
```

## Functions

```scala
def max(x: Int, y: Int): Int = {
    if (x > y) x
    else y
}
```

the function named max takes two Int values and return Int value.

- If a function consists of just one statement, you can leave off the curly braces.
- If a function is not return anything, the result type will be ```Unit```

## Scripts
its possible to write just a sequence of statements in a file.

## Comments
```//```, ```/* */```

## Loop with while

- imperative style
```scala
var i = 0
while (i < args.length) {
    println(args(i))
    i += 1
}
```

## Iterate with foreach and for
- more of a functional style. which is that functions are first class constructs.

```scala
args.foreach((arg: String) => println(arg))
```
it is also possible ```args.foreach(println)```

```scala
for (arg <- args)
println(arg)
```
here, arg is always a val. arg can't be reassigned inside the body of the for expression.

## Parameterize arrays with types
Parameterization means "configuring" an instance when you create it.
1. parameterize an instance with values
example: ```val big = new java.math.BigInteger("12345")```
2. parameterize an instance with both a type and a value
```scala
val greetStrings: Array[String] = new Array[String](3)
greetStrings(0) = "Hello"
greetStrings(1) = ", "
greetStrings(2) = "world!\n"
for (i <- 0 to 2 )
    println(greetStrings(i))
```

note: when you define a variable with val, the variable can't be reassigned, but the object to which it refers could potentially still be changed.
so in this case, you couldn't reassign greetStrings to a different array; but you can change the elements of that Array[String] over time,
so the array itself is mutable.

another way of creating and initializing an array
```scala
val numNames = Array("zero", "one", "two")
```

## Use list
for immutable sequence of objects that share the same type you can use List class.
- List are always immutable
- Scala list is designed to enable a functional style programming.

### Creating and initializing a list
```scala
val oneTwoThree = List(1,2,3)
```

when you call a method on a list that might seem by its name to imply list will mutate, it instead creates and return a new list with the new value.

### Concatenating a list
```scala
val oneTwo = List(1, 2)
val threeFour = List(3, 4)
val oneTwoThreeFour = oneTwo ::: threeFour
```

### Cons ::
prepends a new element to the beginning of an existing list
```scala
val twoThree = List(2, 3)
val oneTwoThree = 1 :: twoThree
```

### Empty list
```Nil``` 

### List methods and usage
| What it is                         | What is does |
|------------------------------------| ----------------------|
|List() or Nil                       | The empty List        |
|var thrill = "Will" :: "fill" :: "until" :: Nil| Create a new List[String] with the three values|
|thrill(2)| Return the element at index 2|
|thrill.count(s => s.length == 4)    | Count the number of string elements that have length 4 |
|thrill.drop(2)|Return the list without its first 2 elements|
|thrill.dropRight(2)|Return the list without its rightmost 2 elements |
|thrill.exists(s => s == "until")| Determines whether a string element exists with value "until" returns bool|
|thrill.filter(s => s.length == 4)| Return a list in order that have length 4|
|
