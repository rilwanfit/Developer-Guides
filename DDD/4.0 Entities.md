---
id: entities
title: DDD
---

## Entity

Consider following example:



*   A person. A person has always an identity and it's always the same regarding their name, or document identifier.
*   An order in an e-commerce system. In that context every new order created has its own identity and it's the same over time.

Entities are objects that have an identity within the application. This means the properties of the Entity can change, but the identity of the Entity will remain consistent.

Most of the time the identity of an entity is represented as a **primitive type**: usually a string or an integer. But using a value object to represent it has more advantages:



*   Value Objects are immutable, so they cannot be modified.
*   Value Objects are complex types that can have custom behaviours that otherwise with primitive types cannot have. Put for example the equality operation. With value objects, equality operations can be modelled and encapsulated in their own classes, making concepts go from implicit to explicit.


### Identity Operation

There are usually 4 ways to define the identity of an entity: 



1.  A client provides the identity,
1.  the application itself provides an identity,
1.  the persistence mechanism provides the identity

MySQL's AUTO_INCREMENT attribute. Major drawback: We won't have the identity of the entity until we persist it. So to some degree, if

we are going with persistence mechanism generated identities we will couple the identity operation with the underlying persistence store.


##### 	Surrogate Identity

Sometimes using an ORM to map entities to a persistence store, some constraints are imposed, for example Doctrine demands of an integer field if an IDENTITY generator strategy is used. This can conflict with the domain model if it requires another kind of identity.

The simplest way to handle that situation is by using a [Layer SuperType](http://martinfowler.com/eaaCatalog/layerSupertype.html) where we put the identity field created for the persistence store.



1.  or another bounded context provides an identity.


### Validation


### The Entity Interface

Entities are objects that have an identity within the application. This means the properties of the Entity can change, but the identity of the Entity will remain consistent.

This means that all Entities should have an identifier.

We can ensure that all Entities do have an identifier with the following interface:


```
namespace App\Domain;

interface Entity
{
   public function id(): Identifier;
}
```



### Aggregate

An aggregate is a cluster of associated objects that we treat as a unit for the purpose of data changes.


### The Aggregate Root Interface

In DDD, Aggregate Root is a very important concept. The Aggregate Root is the most important entity of a particular piece of functionality that controls how other Entities and Value Objects interact.

For example, you might have a Post Aggregate Root that controls interaction with Tag, Comment, Author and Category objects.

A _Comment_ object does not make sense without a _Post_ object and so the _Post_ object controls how access to _Comment_ objects flows.

It is therefore extremely important that we identify Aggregate Root objects because they form the backbone of our project.

Aggregate Roots should always have an identifier as they are Entity Objects. We will also be using 

<p id="gdcalert7" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: undefined internal link (link text: "Domain Events"). Did you generate a TOC? </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert8">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>

[Domain Events](#heading=h.el4uke74nlel) in a following pages so we need a way of recording and releasing Domain Events during the lifecycle of the Aggregate Root.


<table>
  <tr>
   <td>namespace Mhr\Domain;
<p>
interface AggregateRoot
<p>
{
<p>
<em>   </em>public function id(): Identifier;
<p>
   <em>/**</em>
<p>
<em>    * Record that an event as occurred</em>
<p>
<em>    *</em>
<p>
<em>    * @param $event</em>
<p>
<em>    * @return void</em>
<p>
<em>    */</em>
<p>
<em>   </em>public function record($event);
<p>
   <em>/**</em>
<p>
<em>    * Release the events</em>
<p>
<em>    *</em>
<p>
<em>    * @return array</em>
<p>
<em>    */</em>
<p>
<em>   </em>public function release();
<p>
}
   </td>
   <td>trait HasEvents
<p>
{
<p>
<em>   </em>private $events;
<p>
<em>   </em>public function record($event)
<p>
   {
<p>
       $this->events[] = $event;
<p>
   }
<p>
<em>   </em>public function release(): array
<p>
   {
<p>
       $events = $this->events;
<p>
       $this->events = [];
<p>
       return $events;
<p>
   }
<p>
}
   </td>
  </tr>
</table>

### The Has Events Trait

Each Aggregate Root is going to need the implement the record() and release() methods that we have defined in the AggregateRoot interface.

The record method will accept Domain Events as they happen and store them in an array on the Aggregate Root.

At an appropriate time during the execution of the application, those events will be released to trigger actions throughout the application.

Instead of repeating this functionality on each Aggregate Root, we can instead write a trait that can be included: 

<p id="gdcalert8" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: undefined internal link (link text: "Domain Events"). Did you generate a TOC? </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert9">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>

[Domain Events](#heading=h.el4uke74nlel) 

### The User Entity


Tests:

*   write the tests to ensure an Exception is thrown if any of the dependencies are missing:
*   write a test to ensure that a new User is created correctly

```php
class UserTest extends TestCase {
    public function setUp()
    {
        $this->userId = new UserId(Uuid::uuid4());
        $this->email = new Email('name@domain.com');
        $this->username = new Username('my_username');
        $this->password = new Password('super_secret_password');
    }

    ** @test */
    public function should_require_user_id()
    {
        $this->expectException('Exception');
        User::register(null, $this->email, $this->username, $this->password);
    }
    
    /** @test */
    public function should_require_email()
    {
        $this->expectException('Exception');
        User::register($this->userId, null, $this->username, $this->password);
    }
    
    /** @test */
    public function should_require_username()
    {
        $this->expectException('Exception');
        User::register($this->userId, $this->email, null, $this->password);
    }
    
    /** @test */
    public function should_require_password()
    {
        $this->expectException('Exception');
        User::register($this->userId, $this->email, $this->username, null);
    }
    
    /** @test */
    public function should_create_new_user()
    {
        $user = User::register($this->userId, $this->email, $this->username, $this->password);
        $this->assertInstanceOf('Mhr\Domain\Model\Users\User', $user);
        $this->assertInstanceOf('Mhr\Domain\Model\Users\UserId', $user->id());
        $this->assertEquals($user->email(), 'name@domain.com');
        $this->assertEquals($user->username(), 'my_username');
    }
}
```

```php
class User {
    private function __construct(UserId $userId, Email $email, Username $username, Password $password)
    {
        $this->setId($userId);
        $this->setEmail($email);
        $this->setUsername($username);
        $this->setPassword($password);
    }

    public static function register(UserId $userId, Email $email, Username $username, Password $password)
    {
        return new User($userId, $email, $username, $password);
    }
    
    private function setPassword(HashedPassword $password)
    {
        $this->password = $password;
    }
    
    public function getId(): UserId
    {
        return Uuid::fromString($this->id);
    }
}
```


the getters and setters for the class. You will notice that all of the setter methods are set to private. 
I want to be able to control the interface of the User entity and explicitly define how it should be used:
