---
id: services
title: DDD
---
## Domain Services and Infrastructure services

## Testing Domain Services

## Anemic Domain Models Vs Rich Domain Models



### Different types of services

For each layers of the DDD architecture we required to have services

### 1. An Application Service

Operate on scalar types, transforming them into domain types. Scalar types can be considered any type that is unknown to the domain model. This includes primitive and types that do not belong to the domain.

Services of this kind do not contain any business rules nor domain logic. They simply exist to coordinate, orchestrate and execute operations that belong to the domain model.

Application services are the middleware between the outside world and the domain logic. The purpose of such a mechanism is to transform commands from the outside world into meaningful domain instructions.

typically used to orchestrate how the outside world interacts with your application. For example _AuthenticationService_ would be an Application Service that coordinates how a user should be authenticated.

An _Application Service_ should handle the requests and responses from the outside world. The Application Service will orchestrate the various domain objects and services required to fulfil the request.

### 2. An Infrastructure Service

Should be used to abstract the technical concerns and implementations of the outside world. Application should not worry about how the service implemented or work.

For example: message queues, an email provider, a payment gateway or Mailer.

*   Each Infrastructure Service should implement an interface that acts as a contract. The interface should define a public API of methods that should be implemented by the Infrastructure Service.
*   Each technical implementation of an Infrastructure Service sits outside of the boundary of our application and so our application code should depend on the interface contract, and not the concrete implementation.

This is important for a couple of reasons.

1.  it ensures that your application does not depend on any outside service. Each implementation of the Infrastructure Service should be replaceable with another implementation that satisfies the interface contract.
2.  it ensures that your code is easier to test. When you are testing your code you don't want to actually fire off requests to a third-party email provider. Instead you can simply mock the email provider by providing an implementation that satisfies the same interface contract.


### 3.  A Domain Service
*   An important concept in[ Domain Driven Design](http://en.wikipedia.org/wiki/Domain-driven_design) is the modelling of domain logic in Entities and Value Objects.
*   However not every action or piece of functionality will fit neatly into this theoretical workflow. Inevitably we will have a requirement that doesn't quite belong as a method on any of the existing Entities or Value Objects.
*   This is where Domain Services come in. A Domain Service is taken directly from the Ubiquitous Language, but doesn't naturally fit on any existing Domain Object.

### What is Domain Service

*   A Service in DDD is simply **a stateless object that performs an action**.
*   An important characteristic of a Service is that it should not have state. So the _AuthenticationService_ should be used to perform an action such as _authenticate()_ but it should not hold any references to stateful data such as the current authenticated users.

```php
class AuthenticationService { public function authenticate() {}}
```

*   an _AuthenticationService_ would have the sole responsibility for authenticating users into your application


a _Domain Service_ encapsulates business logic that does not naturally fit on any existing domain object. For example, a User requires a hashed password, but it is not the responsibility of the User to hash the password. Instead we can move this functionality to a HashingService.


#### Application Services Use case 01

Let's consider the User signs in into our platform use case. Starting with an outside-in approach, from the delivery mechanism we need to compose the input request for our domain operation. Using a framework like Symfony 2 as the delivery mechanism the code would be something like:

```php
class SignInController extends Controller
{
   public function signInAction(Request $request)
   {
       $signInService = new SignInUserService($this->get('user_repository'));
       try {
           $response = $signInService->execute(new SignInUserRequest(
               $request->request->get('email'),
               $request->request->get('password')
           ));
       } catch(UserAlreadyExistsException $e) {
           $this->render('error.html.twig', $response);
       }
       return $this->render('success.html.twig', $response);
   }
}
```

On the domain side, the Application Service that coordinates the logic that fulfils the User signs in use case: **namespace **Mhr\Application\Service\SignInUserService


### Avoid the Anaemic Model problem

*   Domain Services are a great way to model a particular aspect of your business logic. However over-use of Domain Services leaves you vulnerable to the[ Anaemic Model](http://www.martinfowler.com/bliki/AnemicDomainModel.html) problem.
*   The Anaemic Model problem is where Domain Objects are void of domain logic because it has been abstracted to a service class.
*   For example, you might have a _User_ entity that is basically just an empty class with getters and setters and a _RegisterUser_ service class that actually registers the user within the application.
*   The domain logic of registering a user has been robbed from the natural home of the _User_ entity and put into a service.

_In essence the problem with anaemic domain models is that they incur all of the costs of a domain model, without yielding any of the benefits._



*   It is therefore extremely important that when modelling a particular bit of domain logic, you scrutinise whether it belongs on a Domain Object or as a separate Domain Service.
*   More often than not, you probably don't need a Domain Service. You only need a Domain Service if the piece of domain logic you are modelling does not naturally fit on any Domain Object. A common scenario for this is when the responsibility of the action does not naturally fit on any particular object or if it requires multiple Domain Objects in order to co-ordinate the action.


### Deciding on a Domain Service

An important bit of functionality that we are going to need whilst registering users is the ability to hash passwords. Storing plaintext passwords in the database would be a massive security concern, and so our business logic requires us to ensure that passwords are hashed before they are persisted.

Password hashing is a classic example of a Domain Service, but we will walk through the steps to determine why this is so.

Firstly, our domain explicitly states that passwords should be hashed before they are persisted to the database. Our business rules care about the security of passwords, and so _"hashing passwords"_ comes directly from our ubiquitous language.

Secondly, it's clear that the functionality of hashing a password is stateless. If you think about hashing as an input / output operation, no matter what string you put in, you will always get a hashed password out. The service itself does not store a copy of those passwords and so it is stateless.

Thirdly, a _User_ entity requires a password to be hashed, but it is not the responsibility of the _User_ to hash the password. The _User_ entity only cares about accepting a hashed password, it is not concerned about how the password is actually hashed.

We therefore have a piece of business logic that:

1.  is derived from the ubiquitous language
1.  is stateless
1.  is not the responsibility of any existing domain object

I would say that this is therefore an excellent candidate for a Domain Service.


### Does the Domain Service belong in the Domain Model?

We've established that hashing a password is indeed a Domain Service, but does the actual implementation of hashing a password
belong in the Domain Model?

A Domain Service is derived from the Ubiquitous Language and it encapsulates business logic, so there is no doubting that
it belongs within the Domain Model.

However, Domain Services often use functionality that really does not belong in the Domain.

In the case of hashing a password, our business logic dictates that this is important, but how the password is actually
hashed is not the concern of the Domain.

Therefore we should not have the actual implementation of hashing a password inside of the Domain.

So should this service be in the Domain or not?

To model this functionality correctly we need to define a HashingService interface within the Domain Model and an implementation
that sits within the Infrastructure layer of our application.

This provides the clean separation of the domain requirement from the specific implementation, and it allows us to easily
switch the hashing algorithm we use by simply using a different implementation.

### Domain Service Example
#### 1.  Password Hashing Service

The first thing we need to do is to write the **HashingService interface that is going to sit within our Domain Model**:
```php
namespace App\Domain\Service;
use App\Domain\Model;

interface HashingService
{
    public function hash(Password $password) : HashedPassword;
}
```

```php
namespace Mhr\Tests\Infrastructure\Service;

use Illuminate\Hashing\BcryptHasher;
use Mhr\Domain\Model\User\HashedPassword;
use Mhr\Domain\Model\User\Password;
use Mhr\Infrastructure\Service\BcryptHashingService;

class BcryptHashingServiceTest extends \PHPUnit_Framework_TestCase
{
public function testShouldMakeNewHashedPasswordInstance()
   {
       $service = new BcryptHashingService(new BcryptHasher());

       $hashed = $service->hash(new Password('secret'));

       $this->assertInstanceOf(HashedPassword::class, $hashed);
   }
```
how the password is actually hashed is not the concern of the Domain. Therefore, it goes to Infrastructure
```php
namespace App\Infrastructure\Service;

use Illuminate\Hashing\BcryptHasher;
use Mhr\Domain\Model\User\Password;
use Mhr\Domain\Service\Identity\HashedPassword;
use Mhr\Domain\Service\Identity\HashingService;

class BcryptHashingService implements HashingService
{
   private $hasher;

   public function __construct(BcryptHasher $hasher)
   {
       $this->hasher = $hasher;
   }

   public function hash(Password $password) : HashedPassword
   {
       return new HashedPassword($this->hasher->make((string) $password));
   }
}
```
*   has a single hash() method that accepts an instance of the Password Value Object.
*   return value should be an instance of _HashedPassword_ Value Object that will allow me to type hint to ensure that we only accept hashed passwords.

#### 2. User Registration 


#### Should User Registration be a Domain Service?

previously we looked at

<p id="gdcalert12" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: undefined internal link (link text: "using the ubiquitous language"). Did you generate a TOC? </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert13">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>

[ using the ubiquitous language](#heading=h.pkwp8r6sfqvx) within our code. This lead us to using a static register() method to create a new User.

So we already have a method on an existing Domain object. Shouldn't this functionality be encapsulated on the User object?

the registration functionality should be a Domain Service for a couple of reasons.

1.  an important criteria of the business rules of the application state that **all username and email addresses should be unique**. In order to check for uniqueness we need to query the database. The User object should not be concerned with checking the database.
1.  another important criteria of the business rules is that **passwords should be hashed**. As we saw in[ Creating Domain Services](http://culttt.com/2014/09/29/creating-domain-services), hashing a password shouldn't be the responsibility of the User object either.

So we are faced with a situation where the responsibility of registering new users requires the ability to check the database as well as hashing a password.

This functionality should clearly not be jammed into the User object as the User object should not have the ability to query the database or hash passwords.

With that being said, I think for many applications the functionality of registering a new user should be encapsulated on the User object. If your registration process is not very complicated, abstracting that logic away from the User object would be a mistake.


#### Why isn't this an Application Service?

Application Services control the flow of data as it enters and leaves your application. You can think of Application Services as providing your application with a public API to the outside world.

For the most part I would tend to agree that the registration process for a web application could very well be an Application Service.

The Application Service is responsible for accepting the request from the outside world, processing it, and then returning a response. I think allowing the Application Service to coordinate the various Domain Services and Domain Objects required to register a new user would be a fine solution.

Generally speaking, I want to capture as much of the functionality as I can in Domain Services. Pushing important logic like the registration process out to the Application Services feels to me like I'm losing a bit of the control that I would have if I kept things close to the heart of the application.

If you feel like the architecture of your application makes sense to have the registration process as an Application Service, you should definitely do that. There is no hard and fast rule about what should be a Domain Service verses what should be an Application Service across all types of web application.


##### Create the Register User Service class

```php
class RegisterUserServiceTest {
    public function setUp()
       $this->repository = $this->prophesize(UserRepository::class);
       $this->hashing = $this->prophesize(HashingService::class);
       $this->service = new RegisterUserService(
          $this->repository->reveal(),
          $this->hashing->reveal()
       );
    }
    public function testShouldThrowExceptionIfEmailIsNotUnique()
    {
       $this->expectException(ValueIsNotUniqueException::class);
    
       $this->repository->userOfEmail()->willReturn(true);
    
       $this->service->register('name@domain.com', 'username', 'password');
    }
    
    public function testShouldThrowExceptionIfUsernameIsNotUnique()
    {
       $this->expectException(ValueIsNotUniqueException::class);
    
       $this->repository->userOfEmail()->willReturn(null);
       $this->repository->userOfUsername()->willReturn(true);
    
       $this->service->register('name@domain.com', 'username', 'password');
    }

    public function testShouldRegisterNewUser()
    {
       $this->repository->userOfEmail()->willReturn(null);
       $this->repository->userOfUsername()->willReturn(null);
       $this->repository->nextIdentity()->willReturn(UserId::generate());
       $this->hashing->hash()->willReturn(new HashedPassword('password'));
       $this->repository->add();
    
       $user = $this->service->register('name@domain.com', 'username', 'password');
       $this->assertInstanceOf(User::class, $user);
     }
 }
```


```php
namespace Mhr\Domain\Service\Identity;

class RegisterUserService
{
   public function register($email, $username, $password)
   {
      $email = new Email($email);
      $username = new Username($username);
      $password = new Password($password);
   
      $this->checkEmailIsUnique($email);
      $this->checkUsernameIsUnique($username);
   
      $id = $this->userRepository->nextIdentity();
      $password = $this->hashingService->hash($password);
   
      $user = User::register($id, $email, $username, $password);
      $this->userRepository->add($user);
   
      return $user;

```


This class should have a single **_register_()** method that accepts an $email, $username and $password.

*   The first thing we need to do in register() is to turn the raw $email, $username and $password strings into Value Objects.  If any of the raw input strings do not match the Value Object's internal business logic, an exception will be thrown.
*   Check to ensure that the email and username have not already been registered. Can be achieved via specification pattern.
*   Use the UserRepository to return a new UserId
*   Use the HashingService to hash the password and return a new instance of HashedPassword
*   Using all the details create the User object
*   The $user object can now be passed into the add() method of the UserRepository so it can be persisted to the database

Note: You will notice that _RegisterUserService_ service is making use of two other service classes, but we are in no way relying on the implementation of either of these two classes.


In each test we simply tell the mock to return true to simulate that a user was found with either the email or username and so therefore an exception should be thrown.

In theory you could just inject the HashingService into the RegisterUserService as there really isn't anything to mock, however in this instance I'm just going to mock it out.

This method will be invoked from an Application Service that will accept the returned $user object. This object will be load with[ Domain Events](http://culttt.com/2014/09/22/implementing-domain-events/) that were created during registration and will be ready to fire.


#### Conclusion 01

If your code has any kind of Domain logic, it should definitely be a Domain Service.

However, if you already have a Domain Object where the functionality would naturally fit, it should always be your first priority to avoid using a Domain Service.

Secondly, you don't have to double test the Repository by allowing Domain Services tests to hit the database. Your tests will be unnecessarily slower with little benefit. we don't really care about the return values of from the Repository so there is no point in hitting the database.


#### Conclusion 02

Domain Services are a very important component of Domain Driven Design as they allow you to co-ordinate Domain Objects and protect Entities and Value Objects from assuming too much responsibility.

However it is extremely important that you refrain from over-using Domain Services. A Domain Service seems like a neat solution to a problem, but you can very quickly find yourself in a situation where you have robbed the domain logic from the very objects that need it most.

### Avoid using Domain Services unless they are truly necessary

Domain Services can often steal responsibility away from the Domain Objects. This leaves you in a situation where your Domain Objects are basically just bags of getters and setters, and all of your Domain logic is wrapped up in services.

Domain Services should only be used 

1.  when the functionality does not naturally fit on an existing Domain object, 
1.  the functionality is stateless 
1.  and it will require a coordinated effort of a number of Domain Objects and Services.



# Mailer Infrastructure Service
https://www.culttt.com/2014/10/06/creating-mailer-infrastructure-service/#


## Services in Domain Driven Design


## Why are Infrastructure Services important?


## Why not use Laravel's Mailer class?


## Creating the Mailer Service

So now that I've explained how Infrastructure Services work and why they are so important, we can get down to building the Mailer Service.

This code will live under the main namespace of Infrastructure and will have it's own namespace of Mailer.


### 01. The Message interface
When we send something through the mailer, the object should implement this Message interface. This is so we know that whatever object is passed in will always implement the Message contract and will have the appropriate methods available.

```php
namespace Mhr\Infrastructure\Mailer;

interface Message  
{ 
    public function to(): string;
    public function from(): string;
    public function subject(): string;
    public function body(): string;  
}
```

We will also have an EmailMessage implementation:

```php
class EmailMessage implements Message  
{
    public function __construct(string $to, string $from, string $subject, string $body)  
    {  
    $this->to = $to;  
    $this->from = $from;  
    $this->subject = $subject;  
    $this->body = $body;  
    }
```

Now in theory we could send any type of message along as it implements the Message interface.

A lot of people will tell you it's bad practice to have an interface with only one implementation. However I think that 
is total nonsense. An interface is simply a contract that your code should depend on, it doesn't matter how many implementations you have.


### 02. The Mailer Interface
The Mailer interface should have a single public send() method:
```php
namespace Cribbb\Infrastructure\Mailer;

interface Mailer  
{  
    public function send(Message $message): void;
}  
```

Whenever we need to use the mailer service, the only thing we are going to need to do is to send a message.
This is the single responsibility of this class. We don't care how the email is actually sent, we only care that this single method is available.


#### The MailGun implementation
```php
namespace Cribbb\Infrastructure\Mailer;

class MailGunMailer implements Mailer  
{  
    public function send(Message $message): void
    {  
        // Use the MailGun SDK to send the email  
    }  
}  
```

I'm not going to finish of this concrete implementation off at the moment because I've got bigger fish to fry. We've already set up the interface and the concrete class, so when I need to start sending emails I can just implement the internals of this class.

When I do come to finish off this class I will inject an instance of the[ MailGun SDK](https://github.com/mailgun/mailgun-php) in through the constructor and then implement the send() method to use the SDK and make a request to the MailGun API.

Because we've written the MailGunMailer concrete class using the Mailer interface we don't need to actually implement the class until we really need to send an email. We've already got everything in place to use this contract in tests or in other components of the application.


### Conclusion

Infrastructure Services are an extremely important aspect of your application. We need them to run the various jobs of an application and to co-ordinate the various services outside the scope of our application.

Nearly all web applications will require access to a database, or the ability to send emails. Infrastructure Services deal with these technical details that are not really the responsibility of your particular application.

However, at the end of the day, we don't have to really care about how these Infrastructure Services work. Our applications should not be concerned whether we are using MailGun or SendGrid as the email provider.

The Infrastructure layer of your application should be insulated using interface contracts. Instead of coupling ourselves to these concrete classes, we can use interfaces as boundries.

This not only allows you to easily swap out implementations, but it also makes testing your code a whole lot easier.

However I think the biggest advantage of this pattern of programming is purely the fact that you are writing explicit interfaces and a public API for your application's classes. This kind of explicit programming will make building and maintaining your application a whole lot easier.
