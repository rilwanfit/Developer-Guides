## Repositories

The Repository is responsible for storing and retrieving objects. 

The Repository is not responsible for taking a raw array of data attributes from the request and creating the User 
object internally.

### Benefits of using Repositories

A Repository is basically a layer that sits between your project's domain and the database.

#### 1. Data storage as a detail of the application

The first big benefit of using The Repository Pattern is it moves you closer to thinking about the database as merely 
a detail of the overall application.

A lot of applications get their first burst of growth through the design of the database schema. Whilst many CRUD-centric
applications are very much database oriented, this is the wrong approach for an entirely different suite of applications.

The database is a detail of your application. You should not design your application around how you intend to store the
 data.

The benefit of using The Repository Pattern in this instance is that you can write the **Repository interface** at the
beginning of the project without really thinking about the actual technical details of how you are going to store your data.


```php
namespace App\Domain\Repository;
interface UserRepository {
   public function userByUsername(Username $username): User;
   public function userByEmail(Email $email) : User;
   public function userById() : User;
   public function add(User $user);
   public function remove($id);
   public function nextIdentity() : UserId;
}
```


Why we add a method to return the next identity to use.  When you add an item to a collection, it is the collection that 
is responsible for providing the next identity to be used. Whilst in this case it is not the collection itself that is 
generating the id, we should conceptually follow the same principle.

The **UserRepository is very much part of the application's business logic**. However, the real implementations of the 
Repository are concerns of the infrastructure.

#### 2. Much easier for testing

it make testing your code a lot easier. Whenever you need to add or query data from the database in your application, 
instead of hard coding that dependency, you can inject an instance of an object that satisfies the requirements of your 
Repository interface.

By injecting an object that satisfies an interface we can very easily inject a different implementation during testing 
that does not require the test to hit the database:

```php
public function __construct(UserRepository $repository)
{
    $this->repository = $repository;
}
public function find($id)
{
    return $this->repository->findUserById($id)
}
```

#### 3. A one-way dependency

Good applications are comprised of a number of different layers that each have a single responsibility within the 
software stack. 

The very top layer is the **UI layer**. The User Interface is used for displaying data to the user, accepting user input 
and sending it that input back into the application.

Next we have the **HTTP layer** that accepts the user input and directs where requests should be sent.

Next we have the **Application layer** that coordinates what services we need in order to satisfy the page request.

Next we have the **Domain layer** where the real business logic of the application sits.

And finally at the very bottom we have the database. The database is essentially on the other side of a wall under the 
domain layer because it's not really our responsibility.

Each layer is also essentially oblivious to the layers below.

By using **The Repository Pattern it allows us to create a one-way dependency** between the domain and the data mapping 
layers.


#### 4. The in-memory illusion

One of the most important characteristics of The Repository Pattern is the fact that it provides a "collection-like" 
interface. This means that you should think of accessing the data in your database in the same way you would working 
with a standard collection object.

The fact that we use databases in applications is really because we need some way of storing the data in a persistence 
storage, and so it makes sense to use a database.

We should therefore think of the data as if it is stored in a collection, rather than letting the terminology of the 
database creep into our application.

This means instead of having methods such as `save(User $user)` we should use `add(User $user)`

Why is this important? Well at the end of the day we're still going to be using databases for a long time yet. The fact 
remains though, that the database should not dictate the design or implementation of your application.

By modelling the interaction with the database as behind the curtain of a collection-like interface we move further away 
from the database-centric application design that has held us back for so long.


#### First Repository implementations

Location for repositories :/src/Infrastructure/Repository

1.  in memory implementation that simply stores the data in a really lightweight way: 
```php
class InMemoryUserRepository implements UserRepository {
    private $users;
    public function findUserById($id) {
        return $this->users[$id];
    }
    
    public function findUserByUsername($username) {
        return array_filter($this->users, function ($user) use ($username) {
            return $this->user->username === $username;
        });
    }
    
    public function add(User $user) {
        $this->users[$user->id] = $user;
    }
    
    public function remove($id) {
        unset($this->users[$id]);
    }
}
```

### Tricks for better Repositories

#### Abstracting repeating logic

When working with Repositories, it's pretty likely that you will end up repeating a lot of the same methods. For example you will probably want a method on each Repository to return all entities or find a specific entity by id.

Whenever you find yourself repeating the same code you need to abstract it and then reference that abstraction.

For example if we are using **Laravel Eloquent**

##### 1.  bind UserEloquentRepository as a Service Provider to Laravel Ioc container to resolve the generic interface. 
##### 2.  In the EloquentUserRepository we can then set the injected model as a property on the class
    
```php
protected $model;

public function __construct(User $user)
{
   $this->model = $user;
}
```

##### 3.  Introduce abstract class
```php
namespace Mhr\Infrastructure\Repository;
abstract class AbstractEloquentRepository
{
    public function all() : \Illuminate\Database\Eloquent\Collection
    {
        return $this->model->all();
    }
}
class UserEloquentRepository extends AbstractEloquentRepository implements UserRepository
```

#### Creating an Eager Loading blueprint

Eager loading is extremely useful when you want to load the relationships of an entity to dramatically reduce the number 
of queries that are performed on the database. Eager Loading is basically a way to optimise queries by specifying what 
data you want ahead of time.


*   A common method that is available on a Repository is to find an entity by an id  
`getById(int $id) : Illuminate\Database\Eloquent\Model`
*   This implementation is fine if you only want to return the entity, but what if you also want to return it's 
relationships through eager loading?  The only way to accomplish that is to define another method: 
`getByIdWithUsers(int $id)`

Urgh, we're going to have to repeat a lot of the same logic to implement all of these relationships.

Instead of repeating this logic multiple times we can simply create a query blueprint where we specify the relationships 
to eager load upfront: `make(array $with = [])`

In the getById method we can pass an optional $with parameter so that we can specify what relationships to load whenever 
we call this method: `getById(int $id, array $with = []): Illuminate\Database\Eloquent\Model`

Of course this isn't limited to just the getById method. If you add an optional $with parameter to any of your Repository 
methods and create the stub query using the make method you now have access to eager loading whenever you need it without 
having to repeat any logic!
```php
public function getById(int $id) : Illuminate\Database\Eloquent\Model
{
    return $this->model->find($id);
}

public function getByIdWithPosts(int $id)
{
    return $this->model->find($id)->with(array('posts'))->first();
}

/**
* Make a new instance of the entity to query on
*/
public function make(array $with = [])
{
    return $this->model->with($with);
}

public function getById(int $id, array $with = []) : Illuminate\Database\Eloquent\Model
{
    $query = $this->make($with);
    return $query->find($id);
}
```

#### Get by key value

Another common set of methods on a Repository is getting a selection of entities based upon a key and a value.

For example, you might want to find a user by their email address:

```php
public function findUserByEmail(string $email) {
    return $this->model->where('email', '=', $email)->first();
}

public function getFirstBy($key, $value, array $with = [])
{
    $this->make($with)->where($key, '=', $value)->first();
}

public function getManyBy($key, $value, array $with = [])
{
    $this->make($with)->where($key, '=', $value)->get();
}
```

However if you need to find entities on a Repository using many of these key value searches you end up with a lot of 
repeated logic.

Instead you can simply pass in the key and a value to a generic method. I actually prefer to create two methods, one for 
a single entity and one for many entities. Now you can use the same two methods whenever you want to get find entities by 
a key and a value.


#### Pagination

Pagination is another really common thing that you will probably need on multiple Repositories.
  ...create pagination in symfony...

This is another method that you will likely finding yourself repeating that can be abstracted away from your individual
 Repositories:

```php
public function getByPage($page = 1, $limit = 10, $with = [])
{
    $result = new StdClass;
    
    $result->page = $page;
    
    $result->limit = $limit;
    
    $result->totalItems = 0;
    
    $result->items = [];
    
    $query = $this->make($with);
    
    $model = $query->skip($limit * ($page - 1))
        ->take($limit)
        ->get();
    
    $result->totalItems = $this->model->count();
    
    $result->items = $model->all();
    
    return $result;
}
```

#### Get results that have a particular relationship

Another common type of method to have on a Repository is where you only want to return results that have a particular relationship.

For example, you might want to only return posts that have comments.


<table>
  <tr>
   <td><strong>public function </strong>getPostsWithComments(): Eloquent\Collection
<p>
{
<p>
   $this->model->has('comments')->get();
<p>
}
   </td>
   <td><em>/** Return all results that have a required relationship */</em>
<p>
<strong>public function </strong>has(string $relation, <strong>array </strong>$with = [])
<p>
{
<p>
   $entity = $this->make($with);
<p>
   <strong>return </strong>$entity->has($relation)->get();
<p>
}
   </td>
  </tr>
</table>

## Doctrine Repositories


<p id="gdcalert13" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: undefined internal link (link text: "benefits of using Repositories in web applications."). Did you generate a TOC? </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert14">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>

[benefits of using Repositories in web applications.](#heading=h.5qykk1lkiv0)

There are many benefits to using Repositories in web applications. For example, coding to an interface, hiding the details of the storage provider and making it easier to test your code.

Testing code that depends on a Repository is really easy because we can simply inject a mocked Repository or in-memory implementation during our tests.

But how do you test the Repository classes themselves?


### The separation of interfaces and implementations

An important characteristic of Repositories is the separation of the interface and the implementation.

Repositories are all about the selection of objects. By using a Repository you give the illusion that all objects in the application are held in memory.

It is therefore inevitable that you will need to use Repositories in your domain related code.

Repositories should have an interface and an implementation. We can depend on the interface within our domain related code because the interface is part of our application's business logic.

However we don't really care about the implementation and so the implementation of the Repository must live within the Infrastructure namespace. Theoretically we should be able to replace any Repository implementation.

This separation of the interface and the implementation is very important to realising the full benefit of using Repositories in your applications.


### Recap of the UserRepository interface

The nextIdentity() : UserId; method will return the an instance of UserId. Instead of relying on the database to produce unique id's for my application, I will instead be using UUIDs. The Repository is the "collection" of entities and so it makes sense for the Repository to have the responsibility of creating a new id.

Next we have the add(User $user);   method. The add() method should accept a fully formed User instance. The Repository will then deal with persisting the User to storage.

Similarly the update(User $user);  method should accept an instance of User. Storing the User object is the concern of the Repository and so we can deal with that in the specific implementation of the method.

finally we have two methods to retrieve a user by their email or their username. You could alternatively define a findBy() method that accepts an array of arguments. You would then use this single method for all types of queries. Personally I think being explicit with your methods is a better solution.

Now that we've got the UserRepository interface written, we can start to build out the Doctrine Repository implementation.


### The UserDoctrineRepository class


```
namespace Mhr\Infrastructure\Repository;

use Doctrine\ORM\EntityRepository;
use Mhr\Domain\Model\Identity\UserRepository;

class UserDoctrineRepository extends EntityRepository implements UserRepository
```




*   we've created a plain PHP class called UserDoctrineRepository that implements the UserRepository interface.

A lot of the examples of Doctrine repositories that you will find on the internet will extends Doctrine's EntityRepository.

This is great because it will allow your Repository to inherit a lot of the functionality that you will need.

However it also dilutes the benefit of using the UserRepository interface. If you are relying on Doctrine's abstract methods, you are no longer coding to your explicit Domain interface.

Instead I will inject an instance of the EntityManager in through the constructor. I will also set the class property for the model. This is so we can easily call the default Repository to use those abstract Doctrine Repository methods internally to this class.

Now we can implement each of the methods.


### The next identity method

The nextIdentity() method is very simple to implement because all we need to do is to return a new instance of UserId:

[?](http://culttt.com/2014/10/13/creating-testing-doctrine-repositories/#)


<table>
  <tr>
   <td>1
<p>
2
<p>
3
<p>
4
<p>
5
<p>
6
<p>
7
<p>
8
<p>
9
   </td>
   <td>/**
<p>
 * Return the next identity
<p>
 *
<p>
 * @return UserId
<p>
 */
<p>
public function nextIdentity()
<p>
{
<p>
    return UserId::generate();
<p>
}
   </td>
  </tr>
</table>


The UserId is responsible for creating UUIDs, and so we can use the generate() method to automatically create and return a new instance.


### The add and update methods

The add() and update() methods are also fairly simple to implement:

[?](http://culttt.com/2014/10/13/creating-testing-doctrine-repositories/#)


<table>
  <tr>
   <td>1
<p>
2
<p>
3
<p>
4
<p>
5
<p>
6
<p>
7
<p>
8
<p>
9
<p>
10
<p>
11
<p>
12
<p>
13
<p>
14
<p>
15
<p>
16
<p>
17
<p>
18
<p>
19
<p>
20
<p>
21
<p>
22
<p>
23
   </td>
   <td>/**
<p>
 * Add a new User
<p>
 *
<p>
 * @param User $user
<p>
 * @return void
<p>
 */
<p>
public function add(User $user)
<p>
{
<p>
    $this->em->persist($user);
<p>
    $this->em->flush();
<p>
}
<p>
 
<p>
/**
<p>
 * Update an existing User
<p>
 *
<p>
 * @param User $user
<p>
 * @return void
<p>
 */
<p>
public function update(User $user)
<p>
{
<p>
    $this->em->persist($user);
<p>
    $this->em->flush();
<p>
}
   </td>
  </tr>
</table>


In each of these methods we can simply pass the instance of the User to the persist() method on the EntityManager and then call the flush() method.

If you remember back to[ How is Doctrine 2 different to Eloquent?](http://culttt.com/2014/07/07/doctrine-2-different-eloquent), Doctrine uses a _Unit of Work_ and so we have to explicitly tell it to send the data to the database.


### The userOf methods

And finally we can implement the two userOf methods:

[?](http://culttt.com/2014/10/13/creating-testing-doctrine-repositories/#)


<table>
  <tr>
   <td>1
<p>
2
<p>
3
<p>
4
<p>
5
<p>
6
<p>
7
<p>
8
<p>
9
<p>
10
<p>
11
<p>
12
<p>
13
<p>
14
<p>
15
<p>
16
<p>
17
<p>
18
<p>
19
<p>
20
<p>
21
<p>
22
<p>
23
<p>
24
<p>
25
   </td>
   <td>/**
<p>
 * Find a user by their email address
<p>
 *
<p>
 * @param Email $email
<p>
 * @return User
<p>
 */
<p>
public function userOfEmail(Email $email)
<p>
{
<p>
    return $this->em->getRepository($this->class)->findOneBy([
<p>
        'email' => $email->toString()
<p>
    ]);
<p>
}
<p>
 
<p>
/**
<p>
 * Find a user by their username
<p>
 *
<p>
 * @param Username $username
<p>
 * @return User
<p>
 */
<p>
public function userOfUsername(Username $username)
<p>
{
<p>
    return $this->em->getRepository($this->class)->findOneBy([
<p>
        'username' => $username->toString()
<p>
    ]);
<p>
}
   </td>
  </tr>
</table>


Instead of reinventing the wheel, we can just delegate these methods to the default Doctrine Repository. This is internal to our implementation and so it is hidden from the outside world.

You will notice that I've not implemented a method to delete users. Deleting users is likely going to have business logic implications, and so we can look at that specific bit of functionality in isolation during a future tutorial.


## Testing the Doctrine User Repository

Now that we have written the Repository implementation, we can test it to make sure it is all working correctly.

Many people will tell you that you should not hit the database during your tests. Personally I don't agree with this statement as I think hitting the database is an inevitable part of testing an application.

You should obviously only hit the database in certain types of tests. For example, if you are injecting the Repository into a service class, it's fine to mock the Repository.

Instead of actually hitting a MySQL database, we can instead hit an in-memory SQLite database. This will make running your tests a lot quicker and with less hassle of actually storing the data.

However problems might still creep in due to the differences between MySQL and SQLite. Just because your code passes your tests isn't a guarantee that it will work on your production database.

So the first thing to do is to set up the test class:

[?](http://culttt.com/2014/10/13/creating-testing-doctrine-repositories/#)


<table>
  <tr>
   <td>1
<p>
2
<p>
3
<p>
4
<p>
5
<p>
6
<p>
7
<p>
8
<p>
9
<p>
10
<p>
11
<p>
12
<p>
13
<p>
14
<p>
15
<p>
16
<p>
17
<p>
18
<p>
19
<p>
20
<p>
21
<p>
22
<p>
23
   </td>
   <td><?php namespace Cribbb\Tests\Infrastructure\Repositories;
<p>
 
<p>
use Illuminate\Support\Facades\App;
<p>
use Cribbb\Infrastructure\Repositories\UserDoctrineORMRepository;
<p>
 
<p>
class UserDoctrineORMRepositoryTest extends \TestCase
<p>
{
<p>
    /** @var UserDoctrineORMRepository */
<p>
    private $repository;
<p>
 
<p>
    /** @var EntityManager */
<p>
    private $em;
<p>
 
<p>
    public function setUp()
<p>
    {
<p>
        parent::setUp();
<p>
 
<p>
        Artisan::call('doctrine:schema:create');
<p>
 
<p>
        $this->em     	= App::make('Doctrine\ORM\EntityManagerInterface');
<p>
        $this->repository = new UserDoctrineORMRepository($this->em);
<p>
    }
<p>
}
   </td>
  </tr>
</table>


Before each test I'm going to need Doctrine to create the database schema. Using the[ Laravel Doctrine](https://github.com/mitchellvanw/laravel-doctrine) package, the database will automatically be set to SQLite as long as you have the default database set correctly in your testing config.

Next we can create a new instance of the EntityManager from the IoC container and we can then inject it into the UserDoctrineORMRepository


### The next identity method test

The nextIdentity() method is really simple because we just need to ensure that a new UserId is returned:

[?](http://culttt.com/2014/10/13/creating-testing-doctrine-repositories/#)


<table>
  <tr>
   <td>1
<p>
2
<p>
3
<p>
4
<p>
5
   </td>
   <td>/** @test */
<p>
public function should_return_next_identity()
<p>
{
<p>
    $this->assertInstanceOf('Cribbb\Domain\Model\Identity\UserId', $this->repository->nextIdentity());
<p>
}
   </td>
  </tr>
</table>



### Doctrine Fixtures

Next we need to test the ability to return users that match a certain query. For these types of tests we need to seed the database with records so that we know the query is returning the correct results.

Instead of manually inserting the records before each test, we can instead use fixtures.

Doctrine provides a way of implementing fixtures that can be run before each test to seed the database.

Create a new namespace called Fixtures under the Repositories namespace and copy this file:

[?](http://culttt.com/2014/10/13/creating-testing-doctrine-repositories/#)


<table>
  <tr>
   <td>1
<p>
2
<p>
3
<p>
4
<p>
5
<p>
6
<p>
7
<p>
8
<p>
9
<p>
10
<p>
11
<p>
12
<p>
13
<p>
14
<p>
15
<p>
16
<p>
17
<p>
18
<p>
19
<p>
20
<p>
21
<p>
22
<p>
23
<p>
24
<p>
25
<p>
26
<p>
27
<p>
28
<p>
29
<p>
30
<p>
31
   </td>
   <td><?php namespace Cribbb\Tests\Infrastructure\Repositories\Fixtures;
<p>
 
<p>
use Cribbb\Domain\Model\Identity\User;
<p>
use Cribbb\Domain\Model\Identity\Email;
<p>
use Cribbb\Domain\Model\Identity\UserId;
<p>
use Cribbb\Domain\Model\Identity\Username;
<p>
use Doctrine\Common\Persistence\ObjectManager;
<p>
use Cribbb\Domain\Model\Identity\HashedPassword;
<p>
use Doctrine\Common\DataFixtures\FixtureInterface;
<p>
 
<p>
class UserFixtures implements FixtureInterface
<p>
{
<p>
    /**
<p>
     * Load the User fixtures
<p>
     *
<p>
     * @param ObjectManager $manager
<p>
     * @return void
<p>
     */
<p>
    public function load(ObjectManager $manager)
<p>
    {
<p>
        $id   	= UserId::generate();
<p>
        $email	= new Email('name@domain.com');
<p>
        $username = new Username('username');
<p>
        $password = new HashedPassword('qwerty');
<p>
 
<p>
        $user = User::register($id, $email, $username, $password);
<p>
 
<p>
        $manager->persist($user);
<p>
        $manager->flush();
<p>
    }
<p>
}
   </td>
  </tr>
</table>


Your fixture class should implement the FixtureInterface and should have the load(ObjectManager $manager) method.

Inside this method you can implement how you want the fixture(s) to be created. In the example above I'm creating a single user. However you could write a for loop to create multiple users.

Back in the UserDoctrineORMRepositoryTest we need to set up the fixture infrastructure:

[?](http://culttt.com/2014/10/13/creating-testing-doctrine-repositories/#)


<table>
  <tr>
   <td>1
<p>
2
<p>
3
<p>
4
<p>
5
<p>
6
<p>
7
<p>
8
<p>
9
<p>
10
<p>
11
<p>
12
<p>
13
   </td>
   <td>public function setUp()
<p>
{
<p>
    parent::setUp();
<p>
 
<p>
    Artisan::call('doctrine:schema:create');
<p>
 
<p>
    $this->em     	= App::make('Doctrine\ORM\EntityManagerInterface');
<p>
    $this->repository = new UserDoctrineORMRepository($this->em);
<p>
 
<p>
    $this->executor = new ORMExecutor($this->em, new ORMPurger);
<p>
    $this->loader   = new Loader;
<p>
    $this->loader->addFixture(new UserFixtures);
<p>
}
   </td>
  </tr>
</table>


The last three lines of the setUp() method instantiate the ORMExecutor and the Loader. We also load the UserFixtures class we just implemented.

However we don't need to actually load the fixtures for each test. We don't need to touch the fixtures for the nextIdentity() method and so there is no point in loading them. Instead we can load the fixtures in each of the tests that we need them.


### User of tests

Now that we have the fixtures in place we can write the tests for the user of methods:

[?](http://culttt.com/2014/10/13/creating-testing-doctrine-repositories/#)


<table>
  <tr>
   <td>1
<p>
2
<p>
3
<p>
4
<p>
5
<p>
6
<p>
7
<p>
8
<p>
9
<p>
10
<p>
11
<p>
12
<p>
13
<p>
14
<p>
15
<p>
16
<p>
17
<p>
18
<p>
19
   </td>
   <td>/** @test */
<p>
public function should_find_user_by_username()
<p>
{
<p>
    $this->executor->execute($this->loader->getFixtures());
<p>
 
<p>
    $user = $this->repository->userOfUsername(new Username('username'));
<p>
 
<p>
    $this->assertInstanceOf('Cribbb\Domain\Model\Identity\User', $user);
<p>
}
<p>
 
<p>
/** @test */
<p>
public function should_find_user_by_email()
<p>
{
<p>
    $this->executor->execute($this->loader->getFixtures());
<p>
 
<p>
    $user = $this->repository->userOfEmail(new Email('name@domain.com'));
<p>
 
<p>
    $this->assertInstanceOf('Cribbb\Domain\Model\Identity\User', $user);
<p>
}
   </td>
  </tr>
</table>


In both of these tests we first load the fixtures using the $this->executor instance.

Next we can use the Repository to find the fixture using the username and email address respectively. In each test we should be returned the User instance.


### The add method

To test the add() method we can create a new User instance and pass it to the Repository:

[?](http://culttt.com/2014/10/13/creating-testing-doctrine-repositories/#)


<table>
  <tr>
   <td>1
<p>
2
<p>
3
<p>
4
<p>
5
<p>
6
<p>
7
<p>
8
<p>
9
<p>
10
<p>
11
<p>
12
<p>
13
<p>
14
<p>
15
<p>
16
<p>
17
<p>
18
   </td>
   <td>/** @test */
<p>
public function should_add_new_user()
<p>
{
<p>
    $id   	= UserId::generate();
<p>
    $email	= new Email('name@domain.com');
<p>
    $username = new Username('username');
<p>
    $password = new HashedPassword('qwerty');
<p>
 
<p>
    $this->repository->add(User::register($id, $email, $username, $password));
<p>
 
<p>
    $this->em->clear();
<p>
 
<p>
    $user = $this->repository->userOfUsername(new Username('username'));
<p>
 
<p>
    $this->assertEquals($id,   	$user->id());
<p>
    $this->assertEquals($email,	$user->email());
<p>
    $this->assertEquals($username, $user->username());
<p>
}
   </td>
  </tr>
</table>


We can then query for that user and then assert that the correct user is returned.

Notice how we didn't run the fixtures and so the database is starting the test as empty.


### The update method

For the update() method we don't need to create a new user so we can simply load the fixture.

We can then retrieve the user by their username, update the username and then update the user by passing the object back to the repository.

We can then attempt to find the user by their new username and then assert that the correct user is returned.

Here is what the update method test looks like:

[?](http://culttt.com/2014/10/13/creating-testing-doctrine-repositories/#)


<table>
  <tr>
   <td>1
<p>
2
<p>
3
<p>
4
<p>
5
<p>
6
<p>
7
<p>
8
<p>
9
<p>
10
<p>
11
<p>
12
<p>
13
<p>
14
<p>
15
<p>
16
<p>
17
   </td>
   <td>/** @test */
<p>
public function should_update_existing_user()
<p>
{
<p>
    $this->executor->execute($this->loader->getFixtures());
<p>
 
<p>
    $user = $this->repository->userOfUsername(new Username('username'));
<p>
 
<p>
    $user->updateUsername(new Username('new_username'));
<p>
 
<p>
    $this->repository->update($user);
<p>
 
<p>
    $this->em->clear();
<p>
 
<p>
    $user = $this->repository->userOfUsername(new Username('new_username'));
<p>
 
<p>
    $this->assertInstanceOf('Cribbb\Domain\Model\Identity\User', $user);
<p>
}
   </td>
  </tr>
</table>



## Conclusion

Repositories are a very important component of a lot of different types of application, including Domain Driven Design applications. Repositories make it really easy to test any part of your application that relies on querying the database because it should be very easy to switch out a Repository implementation during your tests.

However, it is also very important that you test your Repositories! If your Repository implementation isn't working correctly, none of your other tests really matter.

When using Repositories you should always rely on the interface and not the specific implementation. It should be very easy to switch out the Repository implementation by using a different concrete class that satisfies the same interface.

It can be tempting to inherit from an abstract Repository that provides a lot of the methods that you are going to need. Whilst this will make your Repository implementations easier to write, you are letting the Infrastructure leak into your application.

When testing Repositories it's inevitable that you are going to hit the database. You can't be sure that a query is working as you expect it to without running the code end-to-end.

Tests that aren't specifically concerned with querying the database should still make mocked calls to the database, but don't try to avoid touching the database at all costs. Your tests will be brittle and not very useful.

And finally, if you need to seed your database with data to ensure your queries are working correctly, use Fixtures as a way of populating data. Tests are hard enough to maintain as they are, you don't need yet another thing to maintain as you continue to develop your application.

