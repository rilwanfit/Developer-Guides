---
id: repositories
title: Repositories
---

## Repositories

A Repository is basically a layer that sits between your project's domain and the database.

The Repository is responsible for storing and retrieving objects. 

#### Who is responsible for creating object from a request object?

### Benefits of using Repositories

#### 1. Data storage as a detail of the application

The first big benefit of using The Repository Pattern is it moves you closer to thinking about the database as merely 
a detail of the overall application.

A lot of applications get their first burst of growth through the design of the database schema. Whilst many CRUD-centric
applications are very much database oriented, this is the wrong approach for an entirely different suite of applications.

The database is a detail of your application. You should not design your application around how you intend to store the
 data.

The benefit of using The Repository Pattern in this instance is that you can write the **Repository interface** at the
beginning of the project without really thinking about the actual technical details of how you are going to store your data.

```php
namespace App\Domain\Repository;
interface UserRepository {
   public function userByUsername(Username $username): User;
   public function userByEmail(Email $email) : User;
   public function userById() : User;
   public function add(User $user);
   public function remove($id);
   public function nextIdentity() : UserId;
}
```

#### What is the usage of nextIdentity? 
Instead of relying on the database to produce unique id's for my application, I will instead be using UUIDs.
The Repository is the "collection" of entities and so it makes sense for the Repository to have the responsibility of creating a new id.


The **UserRepository is very much part of the application's business logic**. However, the real implementations of the 
Repository are concerns of the infrastructure.

#### 2. Much easier for testing

it make testing your code a lot easier. Whenever you need to add or query data from the database in your application, 
instead of hard coding that dependency, you can inject an instance of an object that satisfies the requirements of your 
Repository interface.

By injecting an object that satisfies an interface we can very easily inject a different implementation during testing 
that does not require the test to hit the database:

##### how do you test the Repository classes themselves?
it is also very important that you test your Repositories! If your Repository implementation isn't working correctly, 
none of your other tests really matter.

```php
public function __construct(UserRepository $repository)
{
    $this->repository = $repository;
}
public function find($id)
{
    return $this->repository->findUserById($id)
}
```

#### 3. A one-way dependency

Good applications are comprised of a number of different layers that each have a single responsibility within the 
software stack. 

The very top layer is the **UI layer**. The User Interface is used for displaying data to the user, accepting user input 
and sending it that input back into the application.

Next we have the **HTTP layer** that accepts the user input and directs where requests should be sent.

Next we have the **Application layer** that coordinates what services we need in order to satisfy the page request.

Next we have the **Domain layer** where the real business logic of the application sits.

And finally at the very bottom we have the database. The database is essentially on the other side of a wall under the 
domain layer because it's not really our responsibility.

Each layer is also essentially oblivious to the layers below.

By using **The Repository Pattern it allows us to create a one-way dependency** between the domain and the data mapping 
layers.


#### 4. The in-memory illusion

One of the most important characteristics of The Repository Pattern is the fact that it provides a "collection-like" 
interface. This means that you should think of accessing the data in your database in the same way you would working 
with a standard collection object.

The fact that we use databases in applications is really because we need some way of storing the data in a persistence 
storage, and so it makes sense to use a database.

We should therefore think of the data as if it is stored in a collection, rather than letting the terminology of the 
database creep into our application.

This means instead of having methods such as `save(User $user)` we should use `add(User $user)`

Why is this important? Well at the end of the day we're still going to be using databases for a long time yet. The fact 
remains though, that the database should not dictate the design or implementation of your application.

By modelling the interaction with the database as behind the curtain of a collection-like interface we move further away 
from the database-centric application design that has held us back for so long.

#### 5. coding to an interface, hiding the details of the storage provider

#### First Repository implementations

Location for repositories :/src/Infrastructure/Repository

1.  in memory implementation that simply stores the data in a really lightweight way: 
```php
class InMemoryUserRepository implements UserRepository {
    private $users;
    
    public function findUserById($id) {
        return $this->users[$id];
    }
    
    public function findUserByUsername($username) {
        return array_filter($this->users, function ($user) use ($username) {
            return $this->user->username === $username;
        });
    }
    
    public function add(User $user) {
        $this->users[$user->id] = $user;
    }
    
    public function remove($id) {
        unset($this->users[$id]);
    }
}
```

### Tricks for better Repositories

#### Abstracting repeating logic

When working with Repositories, it's pretty likely that you will end up repeating a lot of the same methods. For example you will probably want a method on each Repository to return all entities or find a specific entity by id.

Whenever you find yourself repeating the same code you need to abstract it and then reference that abstraction.

```php
namespace Mhr\Infrastructure\Repository;
abstract class AbstractRepository
{
    public function all() : Collection
    {
        return $this->model->all();
    }
}
class UserEloquentRepository extends AbstractRepository implements UserRepository
```

#### Creating an Eager Loading blueprint

Eager loading is extremely useful when you want to load the relationships of an entity to dramatically reduce the number 
of queries that are performed on the database. Eager Loading is basically a way to optimise queries by specifying what 
data you want ahead of time.


*   A common method that is available on a Repository is to find an entity by an id  
`getById(int $id) : Model`
*   This implementation is fine if you only want to return the entity, but what if you also want to return it's 
relationships through eager loading?  The only way to accomplish that is to define another method: 
`getByIdWithUsers(int $id)`

Urgh, we're going to have to repeat a lot of the same logic to implement all of these relationships.

Instead of repeating this logic multiple times we can simply create a query blueprint where we specify the relationships 
to eager load upfront: `make(array $with = [])`

In the getById method we can pass an optional $with parameter so that we can specify what relationships to load whenever 
we call this method: `getById(int $id, array $with = []): Model`

Of course this isn't limited to just the `getById` method. If you add an optional $with parameter to any of your Repository 
methods and create the stub query using the make method you now have access to eager loading whenever you need it without 
having to repeat any logic!
```php
public function getById(int $id) : Model
{
    return $this->model->find($id);
}

public function getByIdWithPosts(int $id)
{
    return $this->model->find($id)->with(array('posts'))->first();
}

/**
* Make a new instance of the entity to query on
*/
public function make(array $with = [])
{
    return $this->model->with($with);
}

public function getById(int $id, array $with = []) : Model
{
    $query = $this->make($with);
    return $query->find($id);
}
```

#### Get by key value

Another common set of methods on a Repository is getting a selection of entities based upon a key and a value.

For example, you might want to find a user by their email address:

```php
public function findUserByEmail(string $email) {
    return $this->model->where('email', '=', $email)->first();
}

public function getFirstBy($key, $value, array $with = [])
{
    $this->make($with)->where($key, '=', $value)->first();
}

public function getManyBy($key, $value, array $with = [])
{
    $this->make($with)->where($key, '=', $value)->get();
}
```

However if you need to find entities on a Repository using many of these key value searches you end up with a lot of 
repeated logic.

Instead you can simply pass in the key and a value to a generic method. I actually prefer to create two methods, one for 
a single entity and one for many entities. Now you can use the same two methods whenever you want to get find entities by 
a key and a value.


#### Pagination

Pagination is another really common thing that you will probably need on multiple Repositories.
  ...create pagination in symfony...

This is another method that you will likely finding yourself repeating that can be abstracted away from your individual
 Repositories:

```php
public function getByPage($page = 1, $limit = 10, $with = [])
{
    $result = new StdClass;
    
    $result->page = $page;
    
    $result->limit = $limit;
    
    $result->totalItems = 0;
    
    $result->items = [];
    
    $query = $this->make($with);
    
    $model = $query->skip($limit * ($page - 1))
        ->take($limit)
        ->get();
    
    $result->totalItems = $this->model->count();
    
    $result->items = $model->all();
    
    return $result;
}
```

#### Get results that have a particular relationship

Another common type of method to have on a Repository is where you only want to return results that have a particular relationship.

For example, you might want to only return posts that have comments.

```php
public function getPostsWithComments(): Collection
{
    $this->model->has('comments')->get();
}

/** Return all results that have a required relationship */
public function has(string $relation, array $with = [])
{
    $entity = $this->make($with);
    return $entity->has($relation)->get();
}
```

## Doctrine Repositories

### The separation of interfaces and implementations

An important characteristic of Repositories is the separation of the interface and the implementation.

Repositories are all about the selection of objects. By using a Repository you give the illusion that all objects in the application are held in memory.

It is therefore inevitable that you will need to use Repositories in your domain related code.

Repositories should have an interface and an implementation. We can depend on the interface within our domain related code because the interface is part of our application's business logic.

However we don't really care about the implementation and so the implementation of the Repository must live within the Infrastructure namespace. Theoretically we should be able to replace any Repository implementation.

This separation of the interface and the implementation is very important to realising the full benefit of using Repositories in your applications.


### The UserDoctrineRepository class

```
namespace Mhr\Infrastructure\Repository;

use Doctrine\ORM\EntityRepository;
use Mhr\Domain\Model\Identity\UserRepository;

class UserDoctrineRepository extends EntityRepository implements UserRepository
```

Extending `EntityRepository` will allow your Repository to inherit a lot of the functionality that you will need.

However it also dilutes the benefit of using the UserRepository interface. If you are relying on Doctrine's abstract methods, you are no longer coding to your explicit Domain interface.

> Instead I will inject an instance of the EntityManager in through the constructor. I will also set the class property for the model. This is so we can easily call the default Repository to use those abstract Doctrine Repository methods internally to this class.

Now we can implement each of the methods.


### The next identity method

The nextIdentity() method is very simple to implement because all we need to do is to return a new instance of UserId:

```php
public function nextIdentity(): UserId
{
    return UserId::generate();
}
```

The UserId is responsible for creating UUIDs, and so we can use the generate() method to automatically create and return 
a new instance.


### The add and update methods

```php
public function add(User $user): void
{
    $this->em->persist($user);
    $this->em->flush();
}

public function update(User $user): void
{
    $this->em->persist($user);
    $this->em->flush();
}
```

In each of these methods we can simply pass the instance of the User to the `persist()` method on the EntityManager and 
then call the `flush()` method.

Doctrine uses a _Unit of Work_ and so we have to explicitly tell it to send the data to the database.


### The userBy methods

```php
public function userByEmail(Email $email): User
{
    return $this->em->getRepository($this->class)->findOneBy([
        'email' => $email->toString()
    ]);
}

public function userByUsername(Username $username): User
{
    return $this->em->getRepository($this->class)->findOneBy([
        'username' => $username->toString()
    ]);
}
```

Instead of reinventing the wheel, we can just delegate these methods to the default Doctrine Repository. This is internal 
to our implementation and so it is hidden from the outside world.

## Testing the Doctrine User Repository

Many people will tell you that you should not hit the database during your tests. Personally I don't agree with this 
statement as I think hitting the database is an inevitable part of testing an application.

You should obviously only hit the database in certain types of tests. For example, if you are injecting the Repository 
into a service class, it's fine to mock the Repository.

Instead of actually hitting a MySQL database, we can instead hit an in-memory SQLite database. This will make running 
your tests a lot quicker and with less hassle of actually storing the data.

However problems might still creep in due to the differences between MySQL and SQLite. Just because your code passes 
your tests isn't a guarantee that it will work on your production database.

So the first thing to do is to set up the test class:
```php
use Mhr\Infrastructure\Repositories\UserDoctrineORMRepository;

class UserDoctrineORMRepositoryTest extends \TestCase {
    /** @var UserDoctrineORMRepository */
    private $repository;

    /** @var EntityManager */
    private $em;

    public function setUp() {    
        parent::setUp();
        //Artisan::call('doctrine:schema:create');
        //$this->em = App::make('Doctrine\ORM\EntityManagerInterface');
        $this->repository = new UserDoctrineORMRepository($this->em);
    }
}
```

Before each test I'm going to need Doctrine to create the database schema.
 Using the[ Laravel Doctrine](https://github.com/mitchellvanw/laravel-doctrine) package, 
 the database will automatically be set to SQLite as long as you have the default database set correctly in your testing config.

Next we can create a new instance of the EntityManager from the IoC container and we can then inject it into the UserDoctrineORMRepository


### The next identity method test

The nextIdentity() method is really simple because we just need to ensure that a new UserId is returned:

```php
/** @test */
public function should_return_next_identity()
{
    $this->assertInstanceOf('Mhr\Domain\Model\Identity\UserId', $this->repository->nextIdentity());
}
```

### Doctrine Fixtures

Next we need to test the ability to return users that match a certain query. For these types of tests we need to seed 
the database with records so that we know the query is returning the correct results.

Instead of manually inserting the records before each test, we can instead use fixtures.

Doctrine provides a way of implementing fixtures that can be run before each test to seed the database.

Create a new namespace called Fixtures under the Repositories namespace and copy this file:

```php
use Mhr\Domain\Model\Identity\User;
use Mhr\Domain\Model\Identity\Email;
use Mhr\Domain\Model\Identity\UserId;
use Mhr\Domain\Model\Identity\Username;
use Doctrine\Common\Persistence\ObjectManager;
use Mhr\Domain\Model\Identity\HashedPassword;
use Doctrine\Common\DataFixtures\FixtureInterface;

class UserFixtures implements FixtureInterface
{
    public function load(ObjectManager $manager): void
    {
        $id = UserId::generate();
        $email	= new Email('name@domain.com');
        $username = new Username('username');
        $password = new HashedPassword('qwerty');
        $user = User::register($id, $email, $username, $password);
        $manager->persist($user);
        $manager->flush();
    }
}
```

Your fixture class should implement the FixtureInterface and should have the load(ObjectManager $manager) method.

Inside this method you can implement how you want the fixture(s) to be created. In the example above I'm creating a single user. However you could write a for loop to create multiple users.

Back in the UserDoctrineORMRepositoryTest we need to set up the fixture infrastructure:

```php
public function setUp()
{
    parent::setUp();
    Artisan::call('doctrine:schema:create');
    $this->em = App::make('Doctrine\ORM\EntityManagerInterface');
    $this->repository = new UserDoctrineORMRepository($this->em);
    $this->executor = new ORMExecutor($this->em, new ORMPurger);
    $this->loader = new Loader;
    $this->loader->addFixture(new UserFixtures);
}
```

The last three lines of the setUp() method instantiate the ORMExecutor and the Loader. We also load the UserFixtures class we just implemented.

However we don't need to actually load the fixtures for each test. We don't need to touch the fixtures for the nextIdentity() method and so there is no point in loading them. Instead we can load the fixtures in each of the tests that we need them.


### User of tests

Now that we have the fixtures in place we can write the tests for the user of methods:

```php
/** @test */
public function should_find_user_by_username()
{
    $this->executor->execute($this->loader->getFixtures());
    $user = $this->repository->userOfUsername(new Username('username'));
    $this->assertInstanceOf('Cribbb\Domain\Model\Identity\User', $user);
}

/** @test */
public function should_find_user_by_email()
{
    $this->executor->execute($this->loader->getFixtures());
    $user = $this->repository->userOfEmail(new Email('name@domain.com'));
    $this->assertInstanceOf('Cribbb\Domain\Model\Identity\User', $user);
}
```

In both of these tests we first load the fixtures using the $this->executor instance.

Next we can use the Repository to find the fixture using the username and email address respectively. In each test we should be returned the User instance.


### The add method

To test the add() method we can create a new User instance and pass it to the Repository:

```php
/** @test */
public function should_add_new_user()
{
    $id = UserId::generate();
    
    $email	= new Email('name@domain.com');
    $username = new Username('username');
    $password = new HashedPassword('qwerty');
    
    $this->repository->add(User::register($id, $email, $username, $password));
    
    $this->em->clear();
    $user = $this->repository->userOfUsername(new Username('username'));
    $this->assertEquals($id, $user->id());
    $this->assertEquals($email,	$user->email());
    $this->assertEquals($username, $user->username());
}
```

We can then query for that user and then assert that the correct user is returned.

Notice how we didn't run the fixtures and so the database is starting the test as empty.


### The update method

For the update() method we don't need to create a new user so we can simply load the fixture.

We can then retrieve the user by their username, update the username and then update the user by passing the object back to the repository.

We can then attempt to find the user by their new username and then assert that the correct user is returned.

Here is what the update method test looks like:

```php
/** @test */
public function should_update_existing_user()
{
    $this->executor->execute($this->loader->getFixtures());
    $user = $this->repository->userOfUsername(new Username('username'));
    $user->updateUsername(new Username('new_username'));
    $this->repository->update($user);
    
    $this->em->clear();
    
    $user = $this->repository->userOfUsername(new Username('new_username'));
    
    $this->assertInstanceOf('Mhr\Domain\Model\Identity\User', $user);
}
```
