## Clean Architecture.

A modern approach to create highly maintainable software architecture.


## Architectural Styles.

Key requirement is having a architectural design that fits the application needs.

DDD is not tied to any particular architectural style. We are free to choose the architecture that best fits the needs for every Bounded Context inside the core domain.



*   Order Processing System - Event Sourcing to track all the different order operations
*   Product Catalog - CQRS to expose the product details to the different clients
*   Content Management System - plain Hexagonal Architecture to expose requirements such as blog, static pages and so on..

Data Fabric / SOA


### CQRS: Search Queries

### Layered Architecture

Splitting up concepts and creating layers for each different concern. An essential rule of this way is that each layer may be tightly coupled with the layers beneath it.



<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/DDD3.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/DDD3.png "image_tooltip")


Separation of concerns.


### DDD architecture

The architecture of a Domain Driven Design project is comprised of three main areas. Each areas has it's own unique role and responsibilities within the bigger context of the entire application. It is very important that the responsibility of a particular layer does not leak out into other aspects of the application.


#### The Domain layer

The real business logic of the application should be encapsulated with the Domain Layer. This means that any rules or criteria the application requires should sit within the Domain layer and not leak out into the other layers of the application.

The Domain layer is comprised of Entities and Value Objects as well as Domain Events and other objects that capture the business rules of the application.


#### The Infrastructure Layer

The Infrastructure Layer is made up of all the technical details of how our application is implemented.

For example, most applications require a database and so the code that interacts with the database would sit in the Infrastructure Layer.

how the actions of the model are executed. This could include persisting data to a database, queuing jobs, or sending email notifications.

Domain Driven applications should rely on interfaces and not implementations. This means we would rely on a Mailer interface, but we would use a MailGunMailer implementation that implements the interface we require.


#### Application Layer

*   Acts as a public API to the application. (The Application layer will accept requests from the outside world and return responses in an appropriate manner.)

The Application Layer is important because it acts as an agnostic barrier between the outside world and your application. Your application should not care where a request comes from.

The Application Layer also acts as a conductor by pulling in the services it requires to satisfy a request or send a response. This might mean sending Commands into a Command Bus, or running a query on a Repository.

### MVC

The Model: Captures and centralizes all the domain model behaviour. This layer manages all the data, logic and business rules independently of the data representation. It can be said that the Model layer is the heart and soul of every MVC application.

The Controller: Orchestrates interactions between the other layers (View and Model). Triggers actions on the model in order to update its state and refreshes the representations associated to the model. Additionally, the Controller can also send messages to the View layer in order to change the specific Model representation.

The View: A layer whose main purpose is to expose the differing representations of the Model layer and to give a way to trigger changes on the Model's state.

Example implementation:

```php
declare(strict_types = 1);
namespace Mhr\Ddd;

class Post
{
   private $title;
   private $content;

   private function __construct($title, $content)
   {
       $this->setTitle($title);
       $this->setContent($content);
   }

   public static function writeNewFrom($title, $content)
   {
       return new static($title, $content);
   }

   private function setContent($content)
   {
       $this->assertNotEmpty($content);

       $this->content = $content;
   }

   private function setTitle($title)
   {
       $this->assertNotEmpty($title);

       $this->title = $title;
   }

   public function getTitle()
   {
       return $this->title;
   }

   public function getContent()
   {
       return $this->content;
   }
}
```
```php
class PostService
{
   public function createPost($title, $content)
   {
       $post = Post::writeNewFrom($title, $content);

       (new PostRepository())->add($post);

       return $post;
   }
}
```

```php
class PostRepository
{
   private $db;

   public function __construct()
   {
       $this->db = new \PDO(
           'mysql:host=localhost;dbname=test',
           'username',
           'password',
           [
               \PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES utf8'
           ]
       );
   }

   public function add(Post $post)
   {
       $this->db->beginTransaction();

       try {
           $statement = $this->db->prepare(
               'INSERT INTO posts (title, content) VALUES (?, ?)'
           );

           $statement->exec([
               $post->getTitle(),
               $post->getContent()
           ]);

           $this->db->commit();
       } catch (\Exception $e) {
           $this->db->rollBack();
           throw new UnableToCreatePostExeception($e);
       }
   }
}
```

The Model layer is now defined by a Post class and a PostRepository class. The Post class represents a blog post and the PostRepository class represents the whole collection of blog posts available. Additionally, another layer inside the Model is needed, a layer that coordinates and orchestrates the domain model behaviour: the **Application Layer**.

The PostService is what is known as an Application Service and its purpose is to orchestrate and organize the domain behaviour. In other words, the Application services are the ones that make things happen and they are the direct clients of a Domain Model. No other type of object should

be able to directly talk to the internal layers of the Model layer.


#### View

View layer receives an object, often a Data Transfer Object (DTO) instead of instances of the Model Layer, gathering all the needed information to be successfully represented.

DTOs instead of Model instances?

The main reason and the short answer is, again, Separation of Concerns. Letting the view inspect and use a Model instance leads to tight coupling between the View layer and the Model layer. In fact, a change in the Model layer can potentially break all the views that make use of the changed Model instances.

Let me use Laravel Blade here for view layer.

```bash
composer require "illuminate/view:^5.3"
```
```php

namespace Mhr\Blade;

use Illuminate\Container\Container;
use Illuminate\Contracts\Container\Container as ContainerInterface;
use Illuminate\Events\Dispatcher;
use Illuminate\Filesystem\Filesystem;
use Illuminate\View\ViewServiceProvider;

class Blade
{
   private $viewPaths;

   private $cachePaths;

   protected $container;

   protected $engineResolver;

   public function __construct($viewPaths, $cachePath, ContainerInterface $container = null)
   {
       $this->viewPaths = $viewPaths;
       $this->cachePaths = $cachePath;
       $this->container = $container ?: new Container;

       $this->setUpContainer();

       (new ViewServiceProvider($this->container))->register();

       $this->engineResolver = $this->container->make('view.engine.resolver');
   }

   private function setUpContainer()
   {
       $this->container->bindIf('files', function () {
           return new Filesystem();
       }, true);

       $this->container->bindIf('events', function () {
           return new Dispatcher();
       }, true);

       $this->container->bindIf('config', function () {
           return [
               'view.paths' => (array) $this->viewPaths,
               'view.compiled' => $this->cachePaths,
           ];
       }, true);
   }

   public function render($view, $data = [], $mergeData = [])
   {
       return $this->container['view']->make($view, $data, $mergeData)->render();
   }

   public function compiler()
   {
       return $this->engineResolver->resolve('blade')->getCompiler();
   }

   public function __call($method, $params)
   {
       return call_user_func_array([$this->container['view'], $method], $params);
   }
}
```

```php
namespace Blade\Test;

use Mhr\Blade\Blade;

class BladeTest extends \PHPUnit_Framework_TestCase
{
   private $blade;

   public function setUp()
   {
       $this->blade = new Blade('tests/Blade/views', 'tests/Blade/cache');

       $this->blade->compiler()->directive('datetime', function ($expression) {
           return "<?php //echo with({$expression})->format('F d, Y g:i a); ?>";
       });
   }

   public function testBasic()
   {
       $output = $this->blade->make('basic')->render();
       $this->assertEquals('hello world', trim($output));
   }

   public function testVariables()
   {
       $output = $this->blade->make('variables', ['name' => 'MH Rilwan'])->render();
       $this->assertEquals('hello MH Rilwan', trim($output));
   }

   public function testNoBlade()
   {
       $output = $this->blade->make('plain')->render();
       $this->assertEquals('this is a plain php', trim($output));
   }

   public function testRenderAlias()
   {
       $output = $this->blade->render('basic');
       $this->assertEquals('hello world', trim($output));
   }

   public function testExtendedBlade()
   {
//        $users = require __DIR__ . '/data/users.php';
//        $output = $this->blade->make('extender', $users)->render();

//        $this->assertEquals($output, $this->read('extender'));
   }

   private function read($bladeName)
   {
       return file_get_contents(__DIR__ . '/sample_output/' . $bladeName . '.html');
   }
}
```
```blade
@extends('layout')

@section('title')Post Title@endsection

@section('content')

   @if(count($errors) > 0)
       <div class="alert error">{{ $$errors }} </div>
   @else
       <div class="alert success">Bravo! Post was created successfully!</div>
   @endif

   <div class="container">
       <div class="row">
           <div class="col-sm-12">
               <table class="table table-bordered">
                   @if (count($posts) > 0)
                       <tr>
                           <th>ID</th>
                           <th>TITLE</th>
                           <th>ACTIONS</th>
                       </tr>
                       @foreach ($posts as $post)
                           <tr>
                               <td>{{ $post['id'] }}</td>
                               <td>{{ $post['title'] }}</td>
                               <td>Edit</td>
                           </tr>
                       @endforeach
                   @else
                       <tr>
                           <td colspan="3">No posts found!</td>
                       </tr>
                   @endif
               </table>
           </div>
       </div>
   </div>
@endsection
```

```blade
<!DOCTYPE html>
<html>
<head>
   <title>@yield('title')</title>
</head>
<body>
@yield('content')
</body>
</html>
```

JavaScript MVC framework

*   AngularJS, EmberJS, Marionette, ReactJS

https://github.com/PhiloNL/Laravel-Blade/blob/master/src/Blade.php

[https://github.com/ventoviro/windwalker-renderer](https://github.com/ventoviro/windwalker-renderer)


#### Controller

```php
namespace Mhr\SimpleMvc\Controller;

use Mhr\SimpleMvc\Model\PostService;

class PostsController
{
   public function updateAction(Request $request)
   {
       if ($request->has('submit') && Validator::validate($request->post)) {
           $postService = new PostService();
          
           try {
               $postService->createPost(
                   $request->get('title'),
                   $request->get('content')
               );

               $this->addFlash(
                   'notice',
                   'post has been created successfully!'
               );
           } catch (\Exception $e) {
               $this->addFlash(
                   'error',
                   'Unable to create the post!'
               );
           }
       }
   }
}
```

### Inverting Dependencies. Hexagonal Architecture

In MVC design above, _PostRepository _has the implementation of Infrastructural implementation (low level modules) (i.e. PDO), it is violation of separation of concern and it make harder to test.


#### DIP - Dependency Inversion Principle.



*   High level modules should not be depend upon low level modules. Both should depend upon

    abstractions.

*   Abstraction should not depend upon details. Details should depend upon abstractions.

In above MVC design, The DIP could be applied by relocating the infrastructure layer on top of the other three layers. 


#### Hexagonal Architecture

AKA Ports and Adapters. Represents the application as an hexagon where each side represents a Port with one or more adapters.

A Port is a connector with a pluggable Adapter which transforms an outside input to something the inside application can understand.

In terms of DIP, Port - high level module and adapter - low level module.

Furthermore, if the application needs to emit some message to the outside it will also use a Port with an Adapter to send it and transform it to something that the outside can understand.

