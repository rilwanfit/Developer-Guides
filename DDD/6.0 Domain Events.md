---
id: domain-events
title: DDD
---
## Domain Events
A common requirement within an application is an action should be triggered as a consequence of some other action occurring. This pattern is known as Domain Events.

The usage of events within the context of an application is more commonly known as The [Publish-Subscribe](http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) Pattern.

https://www.reddit.com/r/PHP/comments/34zp6j/i_feel_like_events_are_an_antipattern/

### What are Events?

In programming, an event is just an occurrence of a particular thing at a particular moment in time.

For example: When a new user signs up in your application, you will probably have a list of things that you need to happen.

*   Send the user an email
*   Send analytics notification
*   Subscribe them to your newsletter
*   Suggest the next steps for using your application.
*   Put the user into a queue to suggest potential connection suggestions with our existing users

By defining the user create event, you can set all of these tasks in motion whenever a new user signs up for your application.

That is the basic theory of how events work. Some significant thing is triggered whilst another separate thing listens
for the event to happen and then takes an action.

### Why use Events?

you maintain your separation of concerns. When an event is triggered it does not need to know anything about what will happen as a consequence of firing the event. This allows you to separate your events and your listeners into two distinct areas.

Check how events works;

Using symfony events...

[http://culttt.com/2014/08/04/understanding-doctrine-2-lifecycle-events](http://culttt.com/2014/08/04/understanding-doctrine-2-lifecycle-events)

Domain Events also decouple actions based on their triggers

Domain events should only ever be used to model the events of your domain. These events are core to the domain of your
application and are critical for implementing your business logic.

### What are Domain Events?

*   a Domain Event is an event that is a concern of the domain of the application you are building. 
*   The requirement for Domain Events usually arises from the direct conversations with the client or business expert.

Non-technical people won't refer to Domain Events explicitly, rather they will mention the fact that something needs to
occur as a consequence of another separate action. It is your job as the technical person to understand these statements
and translate them into the correct tool for the job.

As with[ Value Objects](http://culttt.com/2014/08/18/encapsulating-applications-business-rules),[ Specification Objects](http://culttt.com/2014/08/25/implementing-specification-pattern) and[ Entities](http://culttt.com/2014/09/01/user-entity-ubiquitous-language), Domain Events should model a particular part of the domain.

So for instance, if the domain of your application requires that an email confirmation is sent to a new user when they sign up,
this would be a Domain Event because it is a rule of the business you are modelling.

#### How do Domain Events work?

Domain Events work in exactly the same way that an event based architecture works in other contexts.

```php
namespace Mhr\Domain\Model\Identity\Events;
class UserWasRegistered {
    public function __construct(User $user) {
```

```php
namespace listener;
class SendNewUserWelcomeEmail {
    public function __construct(UserWasRegistered $user) { 
```

You will typically create a new event such as _UserWasRegistered_. This will be a class that holds the required details of the event that just took place, in this case an instance a $user object.

Next you will write listeners to listen for the event. For example, you might have a listener called _SendNewUserWelcomeEmail_. This would be a class that accepts the _UserWasRegistered_ event and uses the $user object to send the email.

The _SendNewUserWelcomeEmail_ is responsible for having the ability to send the email and so the process for registering a new user is completely decoupled from the process of sending the email.

You can also register multiple listeners for events so you can very easily add or remove actions that should be fired whenever an event takes place.

### Adding the Domain Events package

Domain Events are certainly not a new concept and so it doesn't make sense to reinvent the wheel on how they should work.
Whenever you can use an open source library to solve your problem you should do so because it is one less concern for your application.

```bash
composer require symfony/event-dispatcher
```

### Domain Events and Aggregate Roots

As I briefly mentioned[ Aggregate Roots](http://culttt.com/2014/09/15/defining-building-blocks-domain-driven-design/) form
 the backbone of our domain model.

You can think of Aggregate Roots as the main entity that controls access to other entities. So for example in the
context of a forum, a _Post_ entity would be the Aggregate Root and so it would act as a gateway to the _Comment_
objects. A Comment does not make sense without a Post and so by restricting access to _Comment_ objects through the 
Post Aggregate Root, we make our code much easier to work with.

The Aggregate Root also controls what Domain Events should be used throughout the lifecycle of the entities it controls.
We can identity an Aggregate Root by using the interface we defined 

https://martinfowler.com/bliki/DDD_Aggregate.html

```php
namespace Mhr\Domain\Model\Identity;
class User implements AggregateRoot {
    use HasEvents;
}
```

Our _AggregateRoot_ interface requires that we implement methods for _record_() and _release_(). These two methods will be used for attaching events during application requests and releasing and dispatching them at the appropriate time.

To satisfy this interface we can use the 

```php
trait HasEvents
{
   private $events;

   public function record($event)
   {
       $this->events[] = $event;
   }

   public function release(): array
   {
       $events = $this->events;

       $this->events = [];

       return $events;
   }
}
```

### Creating Domain Events

Domain Event objects are very simple PHP classes that capture the data of the event that just took place. These classes
can contain whatever is relevant from the event, it's really up to you.

For example, the _UserWasRegistered_ event might look like this:


```
use Mhr\Domain\Model\Identity\Events\UserWasRegistered;
```


You will notice that I've created this class under the Events namespace deep within the Domain\Model\Identity namespace.
Domain Events should live within your Domain related code.

The Domain Event implements the Event interface from the dispatcher package. This interface requires that we have a getName() method that returns the name of the event.

The rest of the class is really up to us. In this example I'm simply injecting the User $user object that was just created during the registration process.

The event is recorded in the User entity when a new object is created:


```php
/**
* Create a new User
*/
private function __construct(UserId $userId, Email $email, Username $username, HashedPassword $password)
{
   $this->setId($userId);
   $this->setEmail($email);
   $this->setUsername($username);
   $this->setPassword($password);

   $this->record(new UserWasRegistered($this));
}
```

### Listening for Events

The beautiful thing about this pattern is the fact that the listeners who are interested in the events are totally
decoupled from the process that triggers the events.

This means you can have multiple separate listeners for each event, and you can add or remove listeners without touching 
any of your existing code.

This also makes listeners really small and easily testable!

When a new user has registered we might want to send them an email to welcome them to the application.

Your listener class might look something like this:


```php
namespace Mhr\Domain\Model\Identity\Listeners;

use Mhr\Mailer;
use BigName\EventDispatcher\Event;
use BigName\EventDispatcher\Listener;

class SendNewUserWelcomeEmail implements Listener
{
    private $mailer
       public function __construct(Mailer $mailer): void
       {
           $this->mailer = $mailer;
       }
    
       public function handle(Event $event): void
       {
           // Send the welcome email
       }
}
```

As you can see, the listener is responsible for sending the email to the new user. With the listener created, we can 
attach it to the event within the Dispatcher:


```php
use Mhrl\Mailer;
use BigName\EventDispatcher\Dispatcher;
use Mhr\Domain\Model\Identity\Listeners\SendNewUserWelcomeEmail;

$listener = new SendNewUserWelcomeEmail(new Mailer);

$dispatcher = new Dispatcher;
$dispatcher->addListener('UserWasRegistered', $listener);
```


You can register any number of listeners to any events that you define within your application. The code above would 
typically be found during the bootstrap process of your application.


#### Dispatching Events

Now that a new User $user object has been created we can dispatch the events that have occurred to trigger the interested listeners.

The User $user object has these pent-up events ready to go. In our example this is only the UserHasRegistered event, but it could be any number of additional events also.

To dispatch the events we simply need to provide the array of events from the User $user object to the dispatch() method of the Dispatcher:


```php
$dispatcher->dispatch($user->release());
```


This will cycle through each event and trigger the listeners to execute their code. In this example that would mean the SendWelcomeEmailListener would send the welcome email to the new user.

[http://reactphp.org/](http://reactphp.org/)

Events using symfony

[https://novemberfive.co/blog/symfony-events-tutorial](https://novemberfive.co/blog/symfony-events-tutorial)


