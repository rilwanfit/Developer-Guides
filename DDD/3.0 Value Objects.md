---
id: value-objects
title: DDD
---

### Value Objects

Value Objects are arguably one of the most important parts of DDD as they allow you to explicitly capture behaviour and encapsulate business  rules in **immutable** objects.

For example: Email, Username and Password objects, dates and times, IPs or co-ordinates, a Product Price, Number, Date, String, Money.

Value Object is a measurement or description of something.

One of the important attributes of a Value Object is that it should have equality with another Value Object instance if they both posses the same properties but equality is not based on identity. This way, you can have multiple copies of the same conceptual value object. Every $5 note

has its own identity (thanks to its serial number), but the cash economy relies on every $5 note having the same value as every other $5 note.

If you want to change a value object you should replace the object with a new one and not be allowed to update the values of the value object itself - updatable value objects lead to aliasing problems.

One of the main goals of Value Objects is also the holy grail of Object Oriented design: **encapsulation**. By following this abstraction, you will end up with a dedicated location to put all the validation, comparison logic and behaviour for a given concept.


#### Characteristics

Value Objects are easier to create, test, use and maintain. With this in mind, you can decide on whether the concept in question could be modelled as a Value Object if… 


##### It measures, quantifies, or describes a thing in the domain.

A Value Object should not be considered just a thing in your Domain. 

For example, the Currency object describes what type of a money is. The Money object measures or quantifies units of a given Currency.

- each Currency is represented with a three upper-case letter ISO code.


<table>
  <tr>
   <td>class Currency
<p>
{
<p>
   private $isoCode;
<p>
   public function __construct(string $anIsoCode)
<p>
   {
<p>
       $this->setIsoCode($anIsoCode);
<p>
   }
<p>
   private function setIsoCode(string $anIsoCode)
<p>
   {
<p>
       if (!preg_match('/^[A-Z]{3}$/', $anIsoCode)) {
<p>
           throw new \InvalidArgumentException();
<p>
       }
<p>
       $this->isoCode = $anIsoCode;
<p>
   }
<p>
   public function isoCode()
<p>
   {
<p>
       return $this->isoCode;
<p>
   }
<p>
}
   </td>
   <td>class Money
<p>
{
<p>
   private $amount;
<p>
   private $currency;
<p>
   public function __construct(int $amount, Currency $currency)
<p>
   {
<p>
       $this->amount = $amount;
<p>
       $this->currency = $currency;
<p>
   }
<p>
   public function amount(): int
<p>
   {
<p>
       return $this->amount;
<p>
   }
<p>
   public function currency(): Currency
<p>
   {
<p>
       return $this->currency;
<p>
   }
<p>
}
   </td>
  </tr>
</table>



##### It can be kept immutable

Object values should not be able to be altered over their lifetime. Because of this immutability, Value Objects are easy to reason, test and are free of undesired/unexpected side-effects.

As such, Value Objects should be created through their constructor. In order to build one, you usually pass the required primitive types or other value objects through this constructor. Value Objects are always in a valid state, that is why we create them in a single atomic step. Empty constructors with multiple setters and getters move the creation responsibility to the client, resulting in the 

<p id="gdcalert6" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: undefined internal link (link text: "Anemic Domain Model"). Did you generate a TOC? </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert7">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>

[Anemic Domain Model](#heading=h.f26muux1zymo), which is considered an anti-pattern.

It is also good to point out that it is not recommended to hold references to entities in your Value Objects. Entities are mutable, and as such this could lead to undesirable side-effects occurring in the Value Object.

In languages with method overloading such as Java, you can create multiple constructors with the same name. Each of these constructors are provided with different options to build the same type of resulting object. In PHP, we are able to provide a similar capability by way of [factory methods](http://en.wikipedia.org/wiki/Factory_method_pattern).

In our Money object we could add some useful factory methods, such as:


<table>
  <tr>
   <td>public function increaseAmountBy($amount)
<p>
{
<p>
   return new self(
<p>
       $this->getAmount() + $amount,
<p>
       $this->getCurrency()
<p>
   );
<p>
}
   </td>
   <td>$money = new Money(100, new Currency('USD'));
<p>
$otherMoney = $money->increaseAmountBy(100);
<p>
var_dump($money === $otherMoney);   // bool(false)
<p>
$money = $money->increaseAmountBy(100);
<p>
var_dump($money === $otherMoney);   // bool(false)
   </td>
  </tr>
</table>


The object returned by _increaseAmountBy_ is different from the one used to invoke the method. This can be observed in the example comparability checks	.


##### It models a conceptual whole, by composing related attributes as an integral unit

So you may be thinking, why not just implement something similar to the following example, avoiding the need for a new Value Object class altogether?


```
class Product {
   private $id;
   private $name;

   private $amount;
   private $currency;
}
```


This approach has some noticeable flaws, if say for example you want to validate the ISO. It does not really make sense for the Product to be responsible for the currency's ISO validation (breaking the Single Responsibility Principle). This is highlighted even more so if you want to reuse the accompanying logic in other parts of your domain (to abide by the DRY principle). With these factors in mind, this use-case is a perfect candidate to be abstracted out into a Value Object. Using this abstraction not only gives you the opportunity to group related properties together, but also to create higher-order concepts and a more concrete Ubiquitous Language.


##### It is completely replaceable when the measurement or description changes

Consider a Product Entity that contains a Money Value Object used to quantify its price. Consider also two Product Entities whose price is identical, for example 100 USD. This scenario could be modelled using two individual Money objects or two references pointing to a single Value Object.

Sharing the same Value Object can be risky, if one is altered, both will reflect the change. This behaviour can be considered an unexpected side-effect. For example, if Carlos was hired on February, 20th, and we know that Christian was also hired on the same day, we may set Christian's hire date to be the same instance as Carlos's. If Carlos then changes the month in his hire date to May, Christian's

hire date changes too. Whether it is correct or not, it is not what people expect.

Due to the problems highlighted in this example when holding a reference to a Value Object, rather than modifying its value, it is recommended instead to replace the object as a whole. 

$this->price = new Money(100, new Currency('USD'));

// ...

$this->price = $this->price->increaseAmountBy(200);

This kind of behaviour is similar to how basic types such as strings work in PHP. Consider the function strtolower , it returns a new string rather than modifying the original one. No reference is used, but instead a new value is returned.


##### It can be compared with others through value equality

Two Value Objects are equal if the content they measure, quantify, or describe is the same.

When using the comparison operator (==), object variables are compared in a simple manner, namely: Two object instances are equal if they have the same attributes and values, and are instances of the same class.

This behaviour works in agreement to our formal definition of a Value Object. However, as an exact class match predicate is present, you should be wary when handling sub-typed Value Objects.

With this in mind, the even stricter === operator unfortunately does not help us. When using the identity operator (===), object variables are identical if and only if they refer to the same instance of the same class.


```
class Money
{
public function equals(Money $money)
{
   return
       $money->getCurrency()->equals($this->getCurrency())
           &&
       $money->getAmount() === $this->getAmount();
}
```



##### It supplies its collaborators with Side-Effect-Free behaviour

Easy to add new behaviors: Example, Money Class with add() method, which has some preconditions to check before adding money.


#### Basic types


<table>
  <tr>
   <td>$a = 10;
<p>
$b = 10;
<p>
var_dump($a == $b); // bool(true)
<p>
var_dump($a === $b); // bool(true)
   </td>
   <td>$a = 20;
<p>
var_dump($a); // integer(20)
<p>
$a = $a + 30;
<p>
var_dump($a); // integer(50)
   </td>
  </tr>
</table>


Although $a and $b are different variables, stored low-level in different memory locations, when compared they are the same. They hold the same value. We consider them equal. You can change the value of $a from 10 to 20 at anytime you want, the new value is 20 and 10 has disappeared. You can replace integer values as much as you want without consideration of the previous value because you are not modifying it, you are just replacing it. If you apply any operation on them such as addition, $a + $b, you get another new value that can be assigned to another variable or a previously defined one. When you pass $a to another function, except if explicitly passed by reference, you are passing

a value. It does not matter if $a gets modified within that function because in your current code, you will still have the original copy. Value Objects behave as basic types.


#### SelfEncapsulation

[https://martinfowler.com/bliki/SelfEncapsulation.html](https://martinfowler.com/bliki/SelfEncapsulation.html)

Self Encapsulation is designing your classes so that all access to data, even from within the same class, goes through accessor methods.

Create getting and setting methods for the field and use only those to access the field.


### Value Object Vs Entity

When people exchange dollar bills, they generally do not distinguish between each unique bill. They are instead only concerned with the face value of the dollar bill. In this context, dollar bills are Value Objects. However, the Federal Reserve might be interested in tracking bills as unique identities and therefore treat them as Entities.

Another example could be that many airlines differentiate among seats, treating them as unique locations. In this instance, a seat can be considered an Entity. On the other hand, there are airlines such as Southwest Airlines (or EasyJet/Ryanair in Europe) that do not differentiate among seats. In this context, a seat could be treated as a Value Object.

Think of address as value object and Entities…..

Context determines that the Object is an Value Object or Entity.


#### Money pattern

[http://martinfowler.com/eaaCatalog/money.html](http://martinfowler.com/eaaCatalog/money.html)

This design pattern provides a solution to model the problem in order to avoid floating-point rounding issue, allowing for deterministic calculations to be performed


#### The Value Object Interface

We will also need to recreate a Value Object from it's native form. For example, when you return a Value Object from a database or HTTP request.

We can enforce that all Value Objects of the application implement these two characteristics by using the following ValueObject interface:


```
namespace App\Domain;

interface ValueObject
{
   public static function fromNative($native) : ValueObject;

   public function equals(ValueObject $object) : bool;
}
```


 

We can also now type hint to ensure that the object we are working with is an instance of **ValueObject**.

It might be handy to also have a toString() method for saving the Value Object to the database or sending the object over the wire during an HTTP request. However instead of defining it as a required method, I will instead just implement it on the instances where it makes sense.


#### Persisting value objects.


### The Identifier Interface

For each Entity we're going to need to create an id Value Object. However, these objects are special types of Value Objects, and so we should define a special interface to represent them.

As with regular Value Objects, we need a way to test for equality and recreate an identifier from a native form (in this case a string).

We also need to be able to generate new identifiers as we add new records to the database, and we will need to convert the object to a string for when we save to the database or send the object over the wire in an HTTP request.

To ensure each identifier class implements these methods we can use the following interface:


```
interface Identifier
{
   public static function generate(): Identifier;
   public static function fromString(string $string) : Identifier;

   public function equals(Identifier $other): bool;

   public function toString(): string;
}
```



### The UUID Abstract Class

we're going to be using UUIDs instead of auto-incrementing ids. However in theory, you could use any number of methods for creating identifying objects along as they implement the Identifier interface.

In order to reduce code duplication, I will make an abstract UuidIdentifier class that can be extended by each identifier implementation. This will mean I don't have to repeat the same boiler plate code each time I need to write a new class.


<table>
  <tr>
   <td>use Rhumsaa\Uuid\Uuid;
<p>
abstract class UuidIdentifier implements Identifier
<p>
{
<p>
<em>   </em>public static function generate():Identifier
<p>
   {
<p>
       return new static(Uuid::<em>uuid4</em>());
<p>
   }
<p>
<em>   </em>public static function fromString(string $string):Identifier
<p>
   {
<p>
       return new static(Uuid::<em>fromString</em>($string));
<p>
   }
<p>
<em>   </em>public function equals(Identifier $other):bool
<p>
   {
<p>
       return $this == $other;
<p>
   }
<p>
<em>   </em>public function toString(): string
<p>
   {
<p>
       return $this->value->toString();
<p>
   }
<p>
<em>   </em>public function __toString(): string
<p>
   {
<p>
       return $this->value->toString();
<p>
   }
<p>
}
   </td>
   <td>namespace App\Domain\Model;
<p>
use Rhumsaa\Uuid\Uuid;
<p>
use Cribbb\Domain\Identifier;
<p>
use Cribbb\Domain\UuidIdentifier;
<p>
class UserId extends UuidIdentifier {
<p>
<em>   </em>protected $value;
<p>
<em>   </em>public function __construct(Uuid $value): void
<p>
   {
<p>
       $this->value = $value;
<p>
   }
<p>
}
   </td>
  </tr>
</table>
