---
id: git-messages
title: DDD
---

# Commit message

A team's approach to its commit log should be no different. In order to create a useful revision history, teams should first agree on a commit message convention that defines at least the following three things:

**Style**. Markup syntax, wrap margins, grammar, capitalization, punctuation. Spell these things out, remove the guesswork, and make it all as simple as possible. The end result will be a remarkably consistent log that's not only a pleasure to read but that actually does get read on a regular basis.

**Content**. What kind of information should the body of the commit message (if any) contain? What should it not contain?

**Metadata**. How should issue tracking IDs, pull request numbers, etc. be referenced?


## The seven rules of a great Git commit message

1.  [Separate subject from body with a blank line](#separate-subject-from-body-with-a-blank-line)
1.  [Limit the subject line to 50 characters](#limit-the-subject-line-to-50-characters)
1.  [Capitalize the subject line](#capitalize-the-subject-line)
4.  [Do not end the subject line with a period](#do-not-end-the-subject-line-with-a-period)
5.  [Use the imperative mood in the subject line](#use-the-imperative-mood-in-the-subject-line)
6.  [Wrap the body at 72 characters](#wrap-the-body-at-72-characters)
7.  [Use the body to explain what and why vs how](#use-the-body-to-explain-what-and-why-vs-how)

Example:

```
Summarize changes in around 50 characters or less

More detailed explanatory text, if necessary. Wrap it to about 72
characters or so. In some contexts, the first line is treated as the
subject of the commit and the rest of the text as the body. The
blank line separating the summary from the body is critical (unless
you omit the body entirely); various tools like `log`, `shortlog`
and `rebase` can get confused if you run the two together.

Explain the problem that this commit is solving. Focus on why you
are making this change as opposed to how (the code explains that).
Are there side effects or other unintuitive consequences of this
change? Here's the place to explain them.

Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used for the bullet, preceded
   by a single space, with blank lines in between, but conventions
   vary here

If you use an issue tracker, put references to them at the bottom,
like this:

Resolves: #123
See also: #456, #789
```
### Separate subject from body with a blank line

From the git commit [manpage](https://www.kernel.org/pub/software/scm/git/docs/git-commit.html#_discussion):

Though not required, it's a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, [git-format-patch(1)](https://mirrors.edge.kernel.org/pub/software/scm/git/docs/git-format-patch.html) turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.

Firstly, not every commit requires both a subject and a body. Sometimes a single line is fine, especially when the change is so simple that no further context is necessary.

Example: Fix typo in introduction to user guide

Nothing more need be said; if the reader wonders what the typo was, she can simply take a look at the change itself, 
i.e. use `git show or git diff or git log -p`


### Limit the subject line to 50 characters

50 characters is not a hard limit, just a rule of thumb. Keeping subject lines at this length ensures that they are readable, and forces the author to think for a moment about the most concise way to explain what's going on.

_Tip: If you're having a hard time summarizing, you might be committing too many changes at once. Strive for 
[atomic commits](https://www.freshconsulting.com/atomic-commits/)

### Capitalize the subject line

This is as simple as it sounds. Begin all subject lines with a capital letter.

For example:
*   Accelerate to 88 miles per hour

Instead of:
*   accelerate to 88 miles per hour


### Do not end the subject line with a period

Trailing punctuation is unnecessary in subject lines. Besides, space is precious when you're trying to keep them to 
[50 chars or less](https://chris.beams.io/posts/git-commit/#limit-50)

Example:
*   Open the pod bay doors

Instead of:
*   Open the pod bay doors.

### Use the imperative mood in the subject line

_Imperative mood_ just means "spoken or written as if giving a command or instruction". A few examples:

*   Clean your room
*   Close the door
*   Take out the trash

Each of the seven rules you're reading about right now are written in the imperative ("Wrap the body at 72 characters", etc.).

The imperative can sound a little rude; that's why we don't often use it. But it's perfect for Git commit subject lines. 
One reason for this is that **Git itself uses the imperative whenever it creates a commit on your behalf**.

For example, the default message created when using git merge reads:

Merge branch 'myfeature'

And when using git revert:

Revert "Add the thing with the stuff"
 
This reverts commit cc87791524aedd593cff5a74532befe7ab69ce9d. 

Or when clicking the "Merge" button on a GitHub pull request:

Merge pull request #123 from someuser/somebranch

So when you write your commit messages in the imperative, you're following Git's own built-in conventions. 
For example:
*   Refactor subsystem X for readability
*   Update getting started documentation
*   Remove deprecated methods
*   Release version 1.0.0

Writing this way can be a little awkward at first. We're more used to speaking in the _indicative mood_, which is all 
about reporting facts. That's why commit messages often end up reading like this:

*   Fixed bug with Y
*   Changing behavior of X

And sometimes commit messages get written as a description of their contents:

*   More fixes for broken stuff
*   Sweet new API methods

To remove any confusion, here's a simple rule to get it right every time.

**A properly formed Git commit subject line should always be able to complete the following sentence**:

*   If applied, this commit will _<span style="text-decoration:underline;">your subject line here</span>_

For example:
*   If applied, this commit will _refactor subsystem X for readability_
*   If applied, this commit will _update getting started documentation_
*   If applied, this commit will _remove deprecated methods_
*   If applied, this commit will _release version 1.0.0_
*   If applied, this commit will _merge pull request #123 from user/branch_

Notice how this doesn't work for the other non-imperative forms:

*   If applied, this commit will _fixed bug with Y_
*   If applied, this commit will _changing behavior of X_
*   If applied, this commit will _more fixes for broken stuff_
*   If applied, this commit will _sweet new API methods_

_Remember: Use of the imperative is important only in the subject line. You can relax this restriction when you're writing the body._


### Wrap the body at 72 characters

Git never wraps text automatically. When you write the body of a commit message, you must mind its right margin, and wrap text manually.

The recommendation is to do this at 72 characters, so that Git has plenty of room to indent text while still keeping everything under 80 characters overall.

A good text editor can help here. It's easy to configure Vim, for example, to wrap text at 72 characters when you're writing a Git commit. Traditionally, however, IDEs have been terrible at providing smart support for text wrapping in commit messages (although in recent versions, IntelliJ IDEA has [finally](https://youtrack.jetbrains.com/issue/IDEA-53615) [gotten](https://youtrack.jetbrains.com/issue/IDEA-53615#comment=27-448299) [better](https://youtrack.jetbrains.com/issue/IDEA-53615#comment=27-446912)about this).


### Use the body to explain what and why vs how

This [commit from Bitcoin Core](https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6) is a great example of explaining what changed and why:

commit eb0b56b19017ab5c16c745e6da39c53126924ed6 \
Author: Pieter Wuille <pieter.wuille@gmail.com> \
Date:   Fri Aug 1 22:57:55 2014 +0200 \
 \
   Simplify serialize.h's exception handling \
 \
   Remove the 'state' and 'exceptmask' from serialize.h's stream \
   implementations, as well as related methods. \
 \
   As exceptmask always included 'failbit', and setstate was always \
   called with bits = failbit, all it did was immediately raise an \
   exception. Get rid of those variables, and replace the setstate \
   with direct exception throwing (which also removes some dead \
   code). \
 \
   As a result, good() is never reached after a failure (there are \
   only 2 calls, one of which is in tests), and can just be replaced \
   by !eof(). \
 \
   fail(), clear(n) and exceptions() are just never called. Delete \
   them. \


Take a look at the [full diff](https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6) and just think how much time the author is saving fellow and future committers by taking the time to provide this context here and now. If he didn't, it would probably be lost forever.

In most cases, you can leave out details about how a change has been made. Code is generally self-explanatory in this regard (and if the code is so complex that it needs to be explained in prose, that's what source comments are for). Just focus on making clear the reasons why you made the change in the first placeâ€”the way things worked before the change (and what was wrong with that), the way they work now, and why you decided to solve it the way you did.

The future maintainer that thanks you may be yourself!


## Tips

### Learn to love the command line. Leave the IDE behind.

For as many reasons as there are Git subcommands, it's wise to embrace the command line. Git is insanely powerful;
 IDEs are too, but each in different ways. I use an IDE every day (IntelliJ IDEA) and have used others extensively 
 (Eclipse), but I have never seen IDE integration for Git that could begin to match the ease and power of the command line 
 (once you know it).

Certain Git-related IDE functions are invaluable, like calling `git rm` when you delete a file, and doing the right stuff 
with git when you rename one. Where everything falls apart is when you start trying to commit, merge, rebase, or do 
sophisticated history analysis through the IDE.

When it comes to wielding the full power of Git, it's command-line all the way.

Remember that whether you use Bash or Zsh or Powershell, there are [tabcompletion](https://git-scm.com/book/en/v2/Appendix-A%3A-Git-in-Other-Environments-Git-in-Bash) [scripts](https://git-scm.com/book/en/v2/Appendix-A%3A-Git-in-Other-Environments-Git-in-Powershell) that take much of the pain out of remembering the subcommands and switches.
